{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Choreo","text":"<p>Choreo is an advanced open-source orchestration framework designed to simplify and enhance how you automate and orchestrate systems. Built on the principles of Kubernetes and leveraging the Kubernetes Resource Model (KRM), it utilizes an event-driven and declarative approach to automation. This versatile platform empowers teams to manage a broad spectrum of systems and processes, including lifecycle management, provisioning, configuration, and application deployment. As a freely available tool, Choreo thrives on the collective expertise and innovation contributed by its vibrant community.</p>"},{"location":"#key-features-of-choreo","title":"Key Features of Choreo","text":"<p>Choreo integrates a range of features designed to streamline operations and foster collaboration, making it a versatile tool for any environment:</p> <ul> <li>Bring Your Own Schema/API: Customization at Your Fingertips: Choreo allows you to integrate your own schemas or APIs, enabling seamless tailoring of the orchestration framework to meet your specific requirements.</li> <li>Service Catalog: Ready-to-Deploy Solutions: Access a rich service catalog offering a variety of pre-defined templates and configurations. This feature speeds up deployment and ensures that best practices are easily adopted.</li> <li>Modular Business Logic: Build As You Go: The framework supports modular business logic, which facilitates easy extensions and adaptations throughout the lifecycle of your projects.</li> <li>Low Code/No Code: Accessibility for Everyone: Choreo\u2019s low-code/no-code capabilities ensure that high levels of automation are achievable without deep coding knowledge, making advanced orchestration accessible to a broader audience.</li> <li>Collaborative Change Management: Streamlined Teamwork: With robust tools for collaborative change management, Choreo ensures that teams can work together efficiently. Changes are easy to track, manage, and review, enhancing transparency and reducing the risk of conflicts or errors.</li> </ul>"},{"location":"#revolutionizing-orchestration","title":"Revolutionizing Orchestration","text":"<p>Choreo is more than just an orchestration engine\u2014it\u2019s a comprehensive solution that transforms how teams interact with technology. By automating complex processes and enabling effective collaboration, Choreo helps you meet your objectives faster and more reliably than ever before. It stands as an indispensable tool for anyone looking to optimize their operations and systems, and harness the power of automation in a scalable, user-friendly environment.</p>"},{"location":"#join-us","title":"Join us","text":"<p>Have questions, ideas, bug reports or just want to chat? Come join discord server.</p>"},{"location":"01-getting-started/01_getting_started/","title":"Getting Started","text":"<p>First check the prerequisites. </p>"},{"location":"01-getting-started/01_getting_started/#setup-environment","title":"Setup environment","text":"<p>This exercise will walk through a basic Hello world example. The API is already generated</p> <p>clone the choreo-examples git repo</p> <pre><code>git clone https://github.com/kform-dev/choreo-examples\n</code></pre> <p>Best to use 2 windows, one for the choreo server and one for the choreo client, since the choreo server will serve the system</p>"},{"location":"01-getting-started/01_getting_started/#choreo-server","title":"choreo server","text":"<p>start the choreoserver</p> <pre><code>choreoctl server start choreo-examples/hello-world/\n</code></pre> <p>The choreoserver support a version controlled backend but we dont explore this in this exercise.</p> <pre><code>{\"time\":\"2024-09-30T19:26:06.771564+02:00\",\"level\":\"INFO\",\"message\":\"server started\",\"logger\":\"choreoctl-logger\",\"data\":{\"name\":\"choreoServer\",\"address\":\"127.0.0.1:51000\"}}\nbranchstore update main oldstate &lt;nil&gt; -&gt; newstate CheckedOut\n</code></pre>"},{"location":"01-getting-started/01_getting_started/#choreo-client","title":"choreo client","text":"<p>With the following command we can explore the api(s) supported by the system. We see the helloworlds api being present, which got loaded when we started the server</p> <pre><code>choreoctl api-resources\n</code></pre> <pre><code>&amp;{upstreamrefs choreo.kform.dev v1alpha1 UpstreamRef  false [pkg knet]}\n&amp;{libraries choreo.kform.dev v1alpha1 Library  false [choreo]}\n&amp;{apiresources choreo.kform.dev v1alpha1 APIResources  true []}\n&amp;{configgenerators choreo.kform.dev v1alpha1 ConfigGenerator  false [pkg knet]}\n&amp;{customresourcedefinitions apiextensions.k8s.io v1 CustomResourceDefinition  false []}\n&amp;{reconcilers choreo.kform.dev v1alpha1 Reconciler  false [choreo]}\n&amp;{helloworlds example.com v1alpha1 HelloWorld HelloWorldList true []}\n</code></pre> <p>When executing the following command no result should be shown, since no hello world resources are loaded</p> <pre><code>choreoctl get customresourcedefinitions.apiextensions.k8s.io\n</code></pre> <p>Autocompletion should work, maybe try TAB completion iso copying the full command</p> <p>Now run the reconciler</p> <pre><code>choreoctl run once\n</code></pre> <p>you should see the reconciler <code>example.com.helloworlds.helloworld</code> being executed.</p> <pre><code>execution success, time(sec) 0.0031725\nReconciler                         Start Stop Requeue Error\nexample.com.helloworlds.helloworld     2    2       0     0\n</code></pre> <p>What just happened?</p> <p>a. the reconciler got loaded</p> HelloWorld Reconciler <pre><code>finalizer = \"helloworld.example.com/ready\"\nconditionType = \"Ready\"\ndef reconcile(self):\n# self = helloworld\nspec = self.get(\"spec\", {})\nspec[\"greeting\"] = \"hello choreo\"\nself['spec'] = spec\nreturn reconcile_result(self, False, 0, conditionType, \"\", False)\n</code></pre> <p>b. The reconciler registered to be informed on any HelloWorld resource change</p> <pre><code>    group: example.com\nversion: v1alpha1\nkind: HelloWorld\n</code></pre> HelloWorld Reconciler Hook <pre><code>apiVersion: choreo.kform.dev/v1alpha1\nkind: Reconciler\n# name can be inferred from the filename or from the for resource\nspec: for: group: example.com\nversion: v1alpha1\nkind: HelloWorld\nselector: {}\n</code></pre> <p>c. The reconciler business logic got triggered by adding this HelloWorld manifest</p> Hello World manifest <pre><code>apiVersion: example.com/v1alpha1\nkind: HelloWorld\nmetadata:\nname: test\nnamespace: default\n</code></pre> <p>let's see if it performed its job, by looking at the details of the HelloWorld manifest</p> <pre><code>choreoctl get helloworlds.example.com test -o yaml\n</code></pre> <p>We should see spec.greeting being changed to <code>hello choreo</code></p> <pre><code>apiVersion: example.com/v1alpha1\nkind: HelloWorld\nmetadata:\nannotations:\napi.choreo.kform.dev/origin: '{\"kind\":\"File\"}'\ncreationTimestamp: \"2024-09-30T17:49:34Z\"\ngeneration: 1\nname: test\nnamespace: default\nresourceVersion: \"1\"\nuid: deedbf64-b348-477e-9fbb-d2738ab4f3b0\nspec:\ngreeting: hello choreo\nstatus:\nconditions:\n- lastTransitionTime: \"2024-09-30T17:49:34Z\"\nmessage: \"\"\nreason: Ready\nstatus: \"True\"\ntype: Ready\n</code></pre> <p>\ud83c\udf89 You ran you first choreo reconciler. \ud83e\udd18</p> <p>Did you notice none of this required a kubernetes cluster? Choreo applies the kubernetes principles w/o imposing all the kubernetes container orchestration primitives.</p> <p>Try changing the business logic from <code>Hello Choreo</code> to <code>hello &lt;your name&gt;</code> and execute the business logic again</p> <pre><code>def reconcile(helloworld):\nspec = helloworld.get(\"spec\", {})\nspec[\"greeting\"] = \"hello wim\"\nhelloworld['spec'] = spec\nreturn reconcile_result(helloworld, False, 0, conditionType, \"\", False)\n</code></pre> <p>This should result in the following outcome if we run the business logic again.</p> <pre><code>choreoctl run once\n</code></pre> <pre><code>apiVersion: example.com/v1alpha1\nkind: HelloWorld\nmetadata:\nannotations:\napi.choreo.kform.dev/origin: '{\"kind\":\"File\"}'\ncreationTimestamp: \"2024-09-30T17:49:34Z\"\ngeneration: 1\nname: test\nnamespace: default\nresourceVersion: \"1\"\nuid: deedbf64-b348-477e-9fbb-d2738ab4f3b0\nspec:\ngreeting: hello wim\nstatus:\nconditions:\n- lastTransitionTime: \"2024-09-30T17:49:34Z\"\nmessage: \"\"\nreason: Ready\nstatus: \"True\"\ntype: Ready\n</code></pre> <p>You can also introduce an error and see what happens; e.g. change <code>greeting</code> to <code>greetings</code> which is an invalid json key in the schema.</p> <pre><code>def reconcile(helloworld):\nspec = helloworld.get(\"spec\", {})\nspec[\"greetings\"] = \"hello wim\"\nhelloworld['spec'] = spec\nreturn reconcile_result(helloworld, False, 0, conditionType, \"\", False)\n</code></pre> <p>when executing</p> <pre><code>choreoctl run once\n</code></pre> <p>the following result is obtained, indicating the schema error</p> <pre><code>execution failed example.com.helloworlds.helloworld.HelloWorld.example.com.test rpc error: code = InvalidArgument desc = fieldmanager apply failed err: failed to create typed patch object (default/test; example.com/v1alpha1, Kind=HelloWorld): .spec.greetings: field not declared in schema\n</code></pre>"},{"location":"01-getting-started/02_prereq/","title":"Prerequisites","text":""},{"location":"01-getting-started/02_prereq/#cpu-architecture","title":"CPU architecture","text":"<p>All the choreo components run on both AMD and ARM based CPU</p>"},{"location":"01-getting-started/02_prereq/#operating-system","title":"Operating system","text":"<p>We tested on WSL for windows and Linux and darwin OS.</p>"},{"location":"01-getting-started/02_prereq/#choreoctl","title":"Choreoctl","text":"<p>Choreoctl is a command line tool for communicating with a Choreo server.</p> <p>choreoctl is a single binary built for linux and Mac OS, distributed via ghreleases. It</p> linux/Mac OSPackages <p>To download &amp; install the latest release the following automated installation script can be used.</p> <pre><code>bash -c \"$(curl -sL https://github.com/kform-dev/choreo/raw/main/install-choreoctl.sh)\"\n</code></pre> <p>As a result, the latest <code>choreoctl</code> version will be installed in the /usr/local/bin directory and the version information will be printed out.</p> <p>To install a specific version of <code>choreoctl</code>, provide the version with -v flag to the installation script:</p> <pre><code>bash -c \"$(curl -sL https://github.com/kform-dev/choreo/raw/main/install-choreoctl.sh)\" -- -v 0.0.1\n</code></pre> <p>Linux users running distributions with support for deb/rpm packages can install choreoctl using pre-built packages:</p> <pre><code>bash -c \"$(curl -sL https://github.com/kform-dev/choreo/raw/main/install-choreoctl.sh)\" -- --use-pkg\n</code></pre>"},{"location":"01-getting-started/02_prereq/#choreoctl-autocomplete","title":"Choreoctl autocomplete","text":"bashzsh <pre><code>source &lt;(choreoctl completion bash) # set up autocomplete in bash into the current shell, bash-completion package should be installed first.\necho \"source &lt;(choreoctl completion bash)\" &gt;&gt; ~/.bashrc # add autocomplete permanently to your bash shell.\n</code></pre> <pre><code>source &lt;(choreoctl completion zsh)  # set up autocomplete in zsh into the current shell\necho '[[ $commands[choreoctl] ]] &amp;&amp; source &lt;(choreoctl completion zsh)' &gt;&gt; ~/.zshrc # add autocomplete permanently to your zsh shell\n</code></pre>"},{"location":"02-userguide/01_about/","title":"About","text":"<p><code>Choreo</code> is an innovative tool designed to bridge the gap between development and production environments through a unified technology framework. Equipped with both server-side and client-side components, <code>Choreo</code> facilitates seamless transitions from development to production, making it an indispensable tool for dynamic application environments.</p>"},{"location":"02-userguide/01_about/#dual-environment-functionality","title":"Dual-Environment Functionality","text":"<p><code>Choreo</code> excels in both development (<code>dev</code>) and production (<code>prod</code>) settings. In development, users can evolve and update a base reference, continually refining their use cases with new data or business logic. In production, <code>Choreo</code> operates using a predefined reference, executing established logic with high reliability and consistency.</p>"},{"location":"02-userguide/01_about/#key-components","title":"Key Components","text":""},{"location":"02-userguide/01_about/#project","title":"Project","text":"<p>A Choreo project is a collection of resources in the form of <code>.yaml</code> or <code>.yml</code> stored in a directory. <code>Choreo</code> uses 3 main sub-directories in a package called <code>crds</code>, <code>in</code> and <code>refs</code>. </p> <ul> <li>The <code>crd</code> directory stores all the external API(s)</li> <li>The <code>in</code> directory stores all the <code>business logic</code> aka <code>programs</code> and <code>input data</code> associated with a project. </li> <li>The <code>refs</code> directory stores all the references to child choreo packages that can include additional <code>crds</code>, <code>business logic</code> or <code>data</code></li> </ul>"},{"location":"02-userguide/01_about/#server","title":"Server","text":"<p>The <code>Choreo</code> server can be initiated in two primary modes:</p> <ul> <li><code>User Mode</code>: This mode is tailored for users who prefer hands-on control over their project environments. Users manually clone a project and direct the Choreo server to the project directory upon startup. This mode fully supports version control operations, allowing users to commit, stash, push, and manage their changes using e.g. standard git commands. It is ideal for developers who need to interact directly with their codebase and version history.</li> <li><code>Choreo Mode</code>: Designed for automated efficiency, this mode enables the server to autonomously manage project directories. It clones repositories based on an immutable reference, suiting both manual interventions and automated processes. While it simplifies repository operations, it still supports a subset of essential version control functions, making it suitable for scenarios where streamlined, consistent deployments and updates are crucial.</li> </ul>"},{"location":"02-userguide/01_about/#runner","title":"Runner","text":"<p><code>Choreo</code>\u2019s runner operates in two distinct modes, catering to different operational needs:</p> <ul> <li><code>Dev Mode</code>: Tailored for development tasks, this mode handles specific operations, executing them to completion and allowing for iterative testing and development. The dev mode is used to test new data input or changing reconciler logic.</li> <li><code>Prod Mode</code>: Designed for production, this mode enables the runner to continuously process and react to events with its built-in reconciler logic, ideal for monitoring and observing ongoing activities within the environment.</li> </ul>"},{"location":"02-userguide/01_about/#result-manager","title":"Result manager","text":"<p>Results from operations are meticulously captured in conditions and stored in snapshots at the end of each run, providing a persistent and immutable record of system states and data outputs. In continuous prod mode, the server must be stopped to finalize and store results, facilitating comprehensive comparisons through diffs between successive runs.</p> <p>More details will be explained in the respective sections of the user guide.</p>"},{"location":"02-userguide/02_project/","title":"Project","text":"<p>A Choreo project is a collection of resources in the form of <code>.yaml</code> or <code>.yml</code> stored in a directory. <code>Choreo</code> uses 3 main sub-directories in a package called <code>crds</code>, <code>in</code> and <code>refs</code>. </p> <ul> <li>The <code>crd</code> directory stores all the external API(s)</li> <li>The <code>in</code> directory stores all the <code>business logic</code> aka <code>programs</code> and <code>input data</code> associated with a project. </li> <li>The <code>refs</code> directory stores all the references to child choreo packages that can include additional <code>crds</code>, <code>business logic</code> or <code>data</code></li> </ul> <p><code>Choreo</code> always runs in the context of a single root package. A complete <code>Choreo</code> configuration consists of a root package and optionally a tree of child packages (if upstream references are referenced in the package)</p> <p>In <code>Choreo</code> CLI, the root package is the working directory where <code>Choreo</code> is invoked/pointed at.</p>"},{"location":"02-userguide/02_project/#apis-and-api-extensions","title":"APIs and API extensions","text":"<p>By using Custom resource definitions you can customize Choreo to orchestrate any use case. <code>CRDs</code> are stored in the <code>crd</code> directory of a choreo package and define the schema of the resource/api used to validate the resources consumed by the API. Choreo API is declarative </p>"},{"location":"02-userguide/02_project/#reconcilers","title":"Reconcilers","text":"<p>Reconcilers define the business logic associated to a resources. When defining a reconciler you define 2 things: - Which resources the reconciler is interested in. - The reconciler business logic. </p> <p>Reconcilers in choreo are built with a <code>low code no code</code> approach in mind to ease the adoption of the system.</p> <p>The following reconciler languages are supported: - starlark - gotemplates - jinja2 templates</p>"},{"location":"02-userguide/02_project/#libraries","title":"Libraries","text":"<p>To allow for more reusable  </p>"},{"location":"02-userguide/02_project/#upstreamrefs","title":"UpstreamRefs","text":"<p><code>Choreo</code> allows for reusable packages accross multiple project through the use of upstream refs. An upstream ref is basically a child <code>Choreo</code> instance of a root <code>Choreo</code> package. </p>"},{"location":"02-userguide/02_project/#data","title":"Data","text":"<p>Besides the built-in choreo apis, input data can also be provided in a choreo package. The input data, aligned with the API definitions, get invoked and will trigger the reconciler business logic defined in the <code>Choreo</code> instance.</p>"},{"location":"02-userguide/03_server/","title":"Choreo Server","text":"<p>The Choreo server initiates with two distinct operational modes: User Mode and Choreo Mode. Each mode is designed to support various development and production needs, ranging from full user control to automated environment management.</p> <ul> <li>User Mode: Provides developers with full control over the project environment, allowing direct interaction with the repository and its version control systems.</li> <li>Choreo Mode: Automates project management tasks, enabling dynamic context management with minimal user intervention.</li> </ul> <p>These modes enable tailored workflows, accommodating both hands-on development practices and streamlined, automated operations for production environments.</p>"},{"location":"02-userguide/03_server/#starting-the-server","title":"Starting the server","text":"<p>To start the Choreo server, use the following command format:</p> <pre><code>choreo server start [DIRECTORY] [flags]\n</code></pre> <p>The presence of a directory argument in the command determines the operational mode of the server:</p> <ul> <li>User Mode: Specify the directory to activate this mode.</li> <li>Choreo Mode: Omit the directory to operate in Choreo Mode.</li> </ul>"},{"location":"02-userguide/03_server/#user-mode","title":"User Mode","text":""},{"location":"02-userguide/03_server/#overview","title":"Overview","text":"<p>In <code>User Mode</code>, the user manually clones a repository and points the Choreo server to either the cloned directory or a subdirectory within it. This mode is primarily used for development, where developers require full control over the version control operations.</p>"},{"location":"02-userguide/03_server/#operations","title":"Operations","text":"<p>To start the server in User Mode, specify the directory path:</p> <pre><code>choreo server start [DIRECTORY] [flags]\n</code></pre> <p>In this mode, the context of the server is fixed to the specified directory, but the user retains the ability to use all version control commands, such as commit, stash, and push. This facilitates an interactive development process where changes can be directly managed and integrated.</p>"},{"location":"02-userguide/03_server/#choreo-mode","title":"Choreo Mode","text":""},{"location":"02-userguide/03_server/#overview_1","title":"Overview","text":"<p>Choreo Mode allows the server to dynamically manage the project\u2019s context. When provided with a repository URL, directory path, and reference, the server autonomously handles the cloning and setup of the repository in a specific directory. This mode supports both development and production environments.</p>"},{"location":"02-userguide/03_server/#operations_1","title":"Operations","text":"<p>To configure the server in Choreo Mode, use the apply command with the necessary repository details:</p> <pre><code>choreo server apply [URL] [DIR] [REF] [BRANCH]\n</code></pre>"},{"location":"02-userguide/03_server/#mode-differentiation","title":"Mode Differentiation","text":"<ul> <li>Development Environment: Specify a branch to indicate that the server should operate in development mode. In this mode, the user or automated systems can instruct the server when to run operations, commit changes, push updates, and create diffs.</li> <li>Production Environment: Omit the branch to default to production mode, typically using the main branch. In this setting, the server operates in a continuous mode, executing the reconciliation logic referenced in the project</li> </ul>"},{"location":"02-userguide/03_server/#dynamic-context-switching","title":"Dynamic Context Switching","text":"<p>you can switch context to the server using the following comamnd. We don`t expect people to switch between production or development, but e.g. in production we can change the reference to rollback to a previous reference that was more stable or to move to a new reference that was validated. In development we will see people commiting chnages to a new branch for new changes to the repo.</p> <pre><code>choreo server apply [URL] [DIR] [REF] [BRANCH]\n</code></pre>"},{"location":"02-userguide/03_server/#status-retrieval","title":"Status Retrieval","text":"<p>To retrieve the current status or configuration of the server, use the get command:</p> <pre><code>choreo server get\n</code></pre> <p>This command is essential for monitoring and managing the server\u2019s state, ensuring transparency and control over the ongoing processes.</p>"},{"location":"02-userguide/04_runner/","title":"Runner","text":"<p>The Choreo runner operates as the execution engine of the platform, capable of running in two distinct modes: Development Mode and Production Mode. These modes are tailored to support different stages of project development and deployment, ensuring both flexibility and robustness in handling resources and executing business logic.</p>"},{"location":"02-userguide/04_runner/#resources","title":"Resources","text":"<p>Choreo is fundamentally an API-first system, utilizing Kubernetes Resource Model (KRM) Custom Resource Definitions (CRDs) as APIs to manage and interact with resources. When the runner is initiated, it loads CRDs and input data from associated directories in the Choreo server. Following data initialization, reconcilers are instantiated to execute their business logic based on the updated resources in the system. This setup leverages a list and watch mechanism, allowing reconcilers to trigger and operate based on the initial loaded data.</p>"},{"location":"02-userguide/04_runner/#development-mode","title":"Development mode","text":""},{"location":"02-userguide/04_runner/#purpose","title":"Purpose","text":"<p>Development mode is designed for testing and validation, ideal for developers looking to verify new data inputs, API functionalities, or business logic changes. This mode provides an iterative environment where changes can be applied, tested, and observed in a controlled setting.</p>"},{"location":"02-userguide/04_runner/#operation","title":"Operation","text":"<p>In Development Mode, the runner operates on a single-run basis, executing the following steps:</p> <ol> <li>Initialization: Loads CRDs and input data into the system.</li> <li>Execution: Starts the reconcilers which consume the data.</li> <li>Observation: An observer component monitors the execution process, assessing outcomes based on various indicators such as error messages, condition statuses, and event triggers.</li> </ol>"},{"location":"02-userguide/04_runner/#completion","title":"Completion","text":"<p>The process concludes when the observer determines the success or failure of the run. The results are then presented to the developer, facilitating quick feedback and iteration.</p> <pre><code>choreoctl run once\n</code></pre>"},{"location":"02-userguide/04_runner/#production-mode","title":"Production mode","text":""},{"location":"02-userguide/04_runner/#purpose_1","title":"Purpose","text":"<p>Production mode is designed for continuous operation, when you decided the input data and business logic is suitable for produciton.</p>"},{"location":"02-userguide/04_runner/#operation_1","title":"Operation","text":"<p>In Production Mode, the runner continuously processes and reacts to changes in the environment, driven by event triggers and updates to the resources:</p> <ol> <li>Start: Initializes and begins continuous processing.</li> <li>Running: Maintains ongoing observation and response to resource changes and system events.</li> <li>Management: Allows for stopping and starting of operations to manage updates or maintenance tasks effectively.</li> </ol> <p>start the server in continuous mode</p> <pre><code>choreoctl run start\n</code></pre> <p>stop the server</p> <pre><code>choreoctl run stop\n</code></pre>"},{"location":"02-userguide/05_results/","title":"Results","text":"<p>In Choreo, results management is intricately designed to cater to both development and production environments, leveraging logs and API interactions to monitor and understand the status and output of operations.</p>"},{"location":"02-userguide/05_results/#production","title":"Production","text":"<p>In a production setting, users/machines can consult logs or interact directly with the API server to check the status of resources. This provides a real-time insight into the system\u2019s operational status, helping identify any issues or confirm the health of the processes.</p>"},{"location":"02-userguide/05_results/#development","title":"Development","text":"<p>The development environment is enhanced with additional tools to aid in testing and troubleshooting:</p> <ul> <li>Observer Insights: The observer component plays a critical role in development mode by informing users about the success or failure of each run. This immediate feedback is crucial for iterative development and troubleshooting.</li> <li>Snapshot Storage: Upon a successful run, a snapshot of the data produced during that operation is stored. This allows developers to capture and review the state of the system at the time of execution, which is invaluable for debugging and historical analysis.</li> </ul>"},{"location":"02-userguide/05_results/#managing-results-with-choreo-commands","title":"Managing Results with Choreo Commands","text":""},{"location":"02-userguide/05_results/#running-and-observing-operations","title":"Running and Observing Operations","text":"<p>To initiate a run and observe the results in development mode, use the following command:</p> <pre><code>choreoctl run once\n</code></pre> <p>This command executes the operational logic once and provides an output summarizing the execution:</p> <pre><code>execution success, time(sec) 0.019575833\nReconciler                                       Start Stop Requeue Error\nnf.nephio.org.nfdeployments.upf.free5gc.io.claim     2    2       0     0\nnf.nephio.org.nfdeployments.upf.free5gc.io.ready     1    1       0     0\n...\n</code></pre>"},{"location":"02-userguide/05_results/#analyzing-changes-with-snapshots","title":"Analyzing Changes with Snapshots","text":"<p>Developers can compare current results with previous snapshots to understand the impact of changes:</p> <pre><code>choreoctl run diff\n</code></pre> <p>This command outputs a detailed list of changes between the current and previous runs, helping identify new or altered resources:</p> <pre><code>+ infra.kuid.dev/v1alpha1, Kind=Cluster nephio.region1.us-east.cluster1\n+ infra.kuid.dev/v1alpha1, Kind=Cluster nephio.region2.us-west.cluster1\n...\n</code></pre> <p>Snapshot Options</p> <p>Choreo also provides options to enhance the detail level in snapshot comparisons:</p> <ul> <li>-i option: Includes internal Choreo API states in the diff.</li> <li>-a option: Displays detailed attributes of each element.</li> <li>-m option: Shows managed fields details, providing deeper insights into what has changed and why.</li> </ul> <p>example with -a option</p> <pre><code>choreoctl run diff\n</code></pre> <p>output</p> <pre><code>+ req.nephio.org/v1alpha1, Kind=DataNetwork nephio.internet.ipv4\n  map[string]any(\n-       nil,\n+       {\n+               \"apiVersion\": string(\"req.nephio.org/v1alpha1\"),\n+               \"kind\":       string(\"DataNetwork\"),\n+               \"metadata\": map[string]any{\n+                       \"annotations\":       map[string]any{\"api.choreo.kform.dev/origin\": string(`{\"kind\":\"File\"}`)},\n+                       \"creationTimestamp\": string(\"2024-10-11T07:03:25Z\"),\n+                       \"finalizers\":        []any{string(\"req.nephio.org.dnns.claim\"), string(\"req.nephio.org.dnns.ready\")},\n+                       \"name\":              string(\"nephio.internet.ipv4\"),\n+                       \"namespace\":         string(\"default\"),\n+                       \"resourceVersion\":   string(\"2\"),\n+                       \"uid\":               string(\"387b5e9d-acb9-4c08-9b95-8cc8239a87e6\"),\n+               },\n+               \"spec\": map[string]any{\"network\": string(\"vpc-internet\"), \"pools\": []any{map[string]any{...}}},\n+               \"status\": map[string]any{\n+                       \"conditions\": []any{map[string]any{...}, map[string]any{...}},\n+                       \"pools\":      []any{map[string]any{...}},\n+               },\n+       },\n  )\n</code></pre>"},{"location":"02-userguide/05_results/#viewing-dependencies","title":"Viewing Dependencies","text":"<p>Understanding dependencies between resources is critical for managing complex systems. Choreo facilitates this with visualization commands that delineate how resources are interconnected:</p> <pre><code>choreoctl deps\n</code></pre> <p>This functionality not only aids in troubleshooting but also helps in planning and verifying system architecture integrity.</p> <pre><code>...\nNFDeployment.nf.nephio.org/v1alpha1 nephio.region1.us-east1.cluster1.upf1\n+-Attachment.req.kuid.dev/v1alpha1 nephio.region1.us-east1.cluster1.upf1.n3\n+-Attachment.req.kuid.dev/v1alpha1 nephio.region1.us-east1.cluster1.upf1.n4\n+-Attachment.req.kuid.dev/v1alpha1 nephio.region1.us-east1.cluster1.upf1.n6\n...\n</code></pre> <p>you can see that NFDeployment.nf.nephio.org/v1alpha1 nephio.region1.us-east1.cluster1.upf1 has 3 children:</p> <ul> <li>Attachment.req.kuid.dev/v1alpha1 nephio.region1.us-east1.cluster1.upf1.n3</li> <li>Attachment.req.kuid.dev/v1alpha1 nephio.region1.us-east1.cluster1.upf1.n4</li> <li>Attachment.req.kuid.dev/v1alpha1 nephio.region1.us-east1.cluster1.upf1.n6</li> </ul>"},{"location":"02-userguide/06_datachanges/","title":"Data input changes","text":"<p>use files in the repo</p> <p>use choreoctl apply</p>"},{"location":"03-devguide/01_about/","title":"Developper guide","text":"<p>The developper guide is designed to help developers extend Choreo with custom APIs and custom business logic (reconcilers) for their use cases.</p>"},{"location":"03-devguide/01_about/#apis","title":"APIs","text":"<p>At the heart of <code>Choreo</code> are its APIs, which are implemented using Custom Resource Definitions (CRDs). These CRDs extend Choreo\u2019s native capabilities, allowing developers to define custom resources specific to their needs. Each API in Choreo is designed to be self-descriptive and aligned with standard KRM practices, ensuring ease of use and integration.</p>"},{"location":"03-devguide/01_about/#reconcilers","title":"Reconcilers","text":"<p>Reconcilers are another pivotal component of <code>Choreo</code>. They attach to a resource in Choreo and react to resource changes triggering necessary updates and adjustments based on their business logic. Choreo support the following reconciler types right now.</p> <ul> <li>go template</li> <li>jinja2 template</li> <li>python/starlark</li> </ul>"},{"location":"03-devguide/apis/01_crd/","title":"API(s)","text":"<p>Choreo adopts an API-first approach, fundamentally leveraging the Kubernetes Resource Model (KRM) as defined by Kubernetes. In this system, each API object represents a resource that Choreo imports using Custom Resource Definitions (CRDs). CRDs allow for the extension of Choreo's capabilities by defining new resource types with associated schemas.</p>"},{"location":"03-devguide/apis/01_crd/#defining-a-crd","title":"Defining a CRD","text":"<p>You can create a CRD in various ways:</p> <ul> <li>manually</li> <li>kubebuilder</li> <li>others: TBD </li> </ul> <p>Each CRD includes several critical pieces of metadata that define how the resource interacts with the API Server:</p> <ul> <li>Group: The API group to which the CRD belongs, helping to categorize and control API extensions.</li> <li>Kind: The type of the resource, which is typically a descriptive name in CamelCase.</li> <li>Version: Indicates the version of the API which can evolve over time.</li> <li>Scope: Determines whether the resource is Namespaced (available within specific namespaces) or Cluster-scoped (available across all namespaces).</li> <li>Names: Includes the plural, singular, and optionally short names used in API requests and user interfaces.</li> </ul>"},{"location":"03-devguide/apis/01_crd/#crd-example","title":"CRD example","text":"<p>Here is an example of a CRD definition for a custom resource named \u201cCronTab\u201d:</p> <pre><code>apiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n# name must match the spec fields below, and be in the form: &lt;plural&gt;.&lt;group&gt;\nname: crontabs.stable.example.com\nspec:\n# group name to use for REST API: /apis/&lt;group&gt;/&lt;version&gt;\ngroup: stable.example.com\n# list of versions supported by this CustomResourceDefinition\nversions:\n- name: v1\n# Each version can be enabled/disabled by Served flag.\nserved: true\n# One and only one version must be marked as the storage version.\nstorage: true\nschema:\nopenAPIV3Schema:\ntype: object\nproperties:\nspec:\ntype: object\nproperties:\ncronSpec:\ntype: string\nimage:\ntype: string\nreplicas:\ntype: integer\n# either Namespaced or Cluster\nscope: Namespaced\nnames:\n# plural name to be used in the URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;\nplural: crontabs\n# singular name to be used as an alias on the CLI and for display\nsingular: crontab\n# kind is normally the CamelCased singular type. Your resource manifests use this.\nkind: CronTab\n# shortNames allow shorter string to match your resource on the CLI\nshortNames:\n- ct\n</code></pre> <p>Key Components of a CRD:</p> <ul> <li>API Version and Kind: Identifies the CRD in the context of the Kubernetes API.</li> <li>Metadata Name: Specifies the name of the CRD in a format .. <li>Spec: Defines the group, versions, and scope of the CRD, including the schema used to validate each version.</li> <li>OpenAPI Schema     Embedded within the CRD is an openAPIV3Schema which specifies the structure and validation rules of the resource. This schema ensures that all instances of the resource conform to the defined specifications, such as required fields, field types, and additional metadata.</li>"},{"location":"03-devguide/apis/01_crd/#crd-usage-in-choreo","title":"CRD Usage in Choreo","text":"<p>In Choreo a CRD is stored in the crd folder of a project and will be imported when the choreo server starts. Once loaded CRUD operations can be performed on these resources.</p>"},{"location":"03-devguide/apis/02_kubebuilder/","title":"Generating crds using kubebuilder","text":"<p>Kubebuilder is a suite that simplifies building Kubernetes APIs using custom resource definitions (CRDs). It leverages Go structs along with controller-runtime annotations to automate and enhance the development process.</p>"},{"location":"03-devguide/apis/02_kubebuilder/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure that Go is installed on your system. You can install Go by following the instructions here: Install go</p>"},{"location":"03-devguide/apis/02_kubebuilder/#setting-up-your-project","title":"Setting Up Your Project","text":"<p>This section demonstrates setting up a basic project structure manually. Typically, this is scaffolded.</p>"},{"location":"03-devguide/apis/02_kubebuilder/#initialize-the-project","title":"Initialize the Project","text":"<p>Create and navigate into a new project directory:</p> <pre><code>mkdir &lt;project-name&gt;; cd &lt;project-name&gt;\ngit init -b main\nmkdir -p apis/\n</code></pre> <p>initialize the go project</p> <p>Note</p> <pre><code>go mod init github.com/dummy/test\n</code></pre>"},{"location":"03-devguide/apis/02_kubebuilder/#prepare-the-makefile","title":"Prepare the Makefile","text":"<pre><code>cat &lt;&lt;\"EOF\" &gt; Makefile\n## Location to install dependencies to\nLOCALBIN ?= $(shell pwd)/bin\n$(LOCALBIN):\n    mkdir -p $(LOCALBIN)\n## Tool Binaries\nCONTROLLER_GEN ?= $(LOCALBIN)/controller-gen\nCONTROLLER_TOOLS_VERSION ?= v0.15.0\n\n# Setting SHELL to bash allows bash commands to be executed by recipes.\n# Options are set to exit when a recipe line exits non-zero or a piped command fails.\nSHELL = /usr/bin/env bash -o pipefail\n.SHELLFLAGS = -ec\n\n.PHONY: manifests\n\nall: manifests\n\n.PHONY: manifests\nmanifests: controller-gen ## Generate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects.\nmkdir -p artifacts\n    $(CONTROLLER_GEN) rbac:roleName=manager-role crd paths=\"./apis/...\" output:crd:artifacts:config=crds\n\n.PHONY: controller-gen\ncontroller-gen: $(CONTROLLER_GEN) ## Download controller-gen locally if necessary.\n$(CONTROLLER_GEN): $(LOCALBIN)\ntest -s $(LOCALBIN)/controller-gen || GOBIN=$(LOCALBIN) go install sigs.k8s.io/controller-tools/cmd/controller-gen@$(CONTROLLER_TOOLS_VERSION)\nEOF\n</code></pre>"},{"location":"03-devguide/apis/02_kubebuilder/#generate-manifests","title":"Generate Manifests","text":"<pre><code>make manifests\n</code></pre>"},{"location":"03-devguide/apis/02_kubebuilder/#creating-your-first-api","title":"Creating Your First API","text":"<p>create a directory where we store your api artifacts</p> <pre><code>mkdir -p apis/foo/v1alpha1\n</code></pre> <p>create a doc.go file and the test_types.go file containing the api</p> <pre><code>cat &lt;&lt;\"EOF\" &gt; apis/foo/v1alpha1/doc.go\n// +kubebuilder:object:generate=true\n// +groupName=foo.example.com\n// Package v1alpha1 is the v1alpha1 version of the API.\npackage v1alpha1\nEOF\n</code></pre> <pre><code>cat &lt;&lt;\"EOF\" &gt; apis/foo/v1alpha1/test_types.go\npackage v1alpha1\n\nimport (\nmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n// TestSpec defines the desired state of the Test resource\ntype TestSpec struct {\n}\n// TestStatus defines the observed state of the Test resource\ntype TestStatus struct {\n}\n// +kubebuilder:object:root=true\n// +kubebuilder:subresource:status\n// Test is the Schema for the Test API\ntype Test struct {\nmetav1.TypeMeta   `json:\",inline\"`\nmetav1.ObjectMeta `json:\"metadata,omitempty\"`\nSpec   TestSpec   `json:\"spec,omitempty\"`\nStatus TestStatus `json:\"status,omitempty\"`\n}\n// TestList contains a list of Tests\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\ntype TestList struct {\nmetav1.TypeMeta `json:\",inline\" yaml:\",inline\"`\nmetav1.ListMeta `json:\"metadata,omitempty\"`\nItems           []Test `json:\"items\"`\n}\nEOF\n</code></pre> <p>run go mod tidy to resolve the dependencies</p> <pre><code>go mod tidy\n</code></pre> <p>generate your api</p> <pre><code>make manifests\n</code></pre> <p>start the server</p> <pre><code>choreoctl server start .\n</code></pre> <pre><code>choreoctl apply &lt;&lt;EOF\napiVersion: foo.example.com/v1alpha1\nkind: Test\nmetadata:\n  name: my-first-test\nEOF\n</code></pre>"},{"location":"03-devguide/apis/02_kubebuilder/#adding-parameters-with-validation","title":"Adding parameters with validation","text":"<p>crd generation</p> <p>crd validation</p> <pre><code>type TestSpec struct {\n// +kubebuilder:validation:MaxLength=15\n// +kubebuilder:validation:MinLength=3\n// FieldA defines the name of field A\nFieldA string `json:\"fieldA,omitempty\"`\n}\n</code></pre> <p>create an object with an empty fieldA in spec -&gt; acceppted</p> <pre><code>choreoctl apply &lt;&lt;EOF\napiVersion: foo.example.com/v1alpha1\nkind: Test\nmetadata:\nname: my-first-test\nspec:\nEOF\n</code></pre> <p>create an object with a fieldA but with 1 char in spec -&gt; rejected</p> <pre><code>choreoctl apply - &lt;&lt;EOF\napiVersion: foo.example.com/v1alpha1\nkind: Test\nmetadata:\nname: my-first-test\nspec:\nfieldA: w\nEOF\n</code></pre> <p>create an object with a fieldA but with 3 char in spec -&gt; accepted</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: foo.example.com/v1alpha1\nkind: Test\nmetadata:\nname: my-first-test\nspec:\nfieldA: wim\nEOF\n</code></pre>"},{"location":"03-devguide/apis/02_kubebuilder/#examples-of-additional-parameters-with-constraints","title":"Examples of additional parameters with constraints","text":"<pre><code>type TestSpec struct {\n// +kubebuilder:validation:MaxItems=2\n// ListA defines a list of A\nListA []string `json:\"listA,omitempty\"`\n// +kubebuilder:validation:Enum=unknown;gnmi;netconf;noop;ssh;\n// +kubebuilder:default:=\"gnmi\"\n// Protocol defines the protocol to connect to the device\nProtocol string `json:\"protocol\"`\n// +kubebuilder:validation:Pattern=`(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))`\n// Address defines the ip address to connect to the host\nAddress string `json:\"address\"`\n// +kubebuilder:validation:Minimum=1\n// +kubebuilder:validation:Maximum=200\n// +kubebuilder:default:=100\nPriority   *uint8 `json:\"priority,omitempty\"`\n}\n</code></pre>"},{"location":"03-devguide/reconcilers/01_reconciler/","title":"Reconciler Introduction","text":"<p>In <code>Choreo</code>, <code>reconcilers</code> are essential components that synchronize the desired state of resources with their actual state in the system. They are tightly integrated with the API server, responding to changes in resources and executing their corresponding business logic.  </p> <p>When configuring a reconciler in <code>Choreo</code>, developers define two crucial aspects:</p> <ul> <li>Attachment Specifications: Specifies which resources or resource types the reconciler attaches to within the system.</li> <li>Business Logic: Dictates how the reconciler responds to changes, including the transformations it applies to resources.</li> </ul> <p>The attachment is detailed in the reconciler configuration, while the business logic is implemented in the language of the developer\u2019s choice.</p>"},{"location":"03-devguide/reconcilers/01_reconciler/#reconciler-configuration","title":"Reconciler Configuration","text":"<p>Reconcilers in Choreo attach to resources using event handlers, enabling specific interactions based on the resource type:</p> <ul> <li>For Resource: This is the primary resource that the reconciler manages directly. Each instance of this resource is handled in its own Go routine, ensuring isolated and efficient management.</li> <li>Watch Resource: These are the resources that the reconciler depends on for executing its logic. Changes in these resources can trigger the reconciler to act on the primary resource. Examples of watch resources are templates or external source of data</li> <li>Own Resource: These are resources that the reconciler creates as a result of its operations. Managing these resources involves tracking dependencies and cleanup via owner references and finalizers. </li> </ul>"},{"location":"03-devguide/reconcilers/01_reconciler/#reconciler-logic","title":"Reconciler Logic","text":"<p>Reconcilers are designed to be idempotent and language-agnostic, allowing for diverse implementation strategies. In <code>Choreo</code> we aim for ease of use to optimize the development experience.</p> <p>Managing the complete lifecycle of resources\u2014such as creation, updates, and cleanup\u2014can be complex, often requiring developers to handle intricate historical data and state changes. Choreo simplifies this aspect of reconciler implementation by abstracting the historical management of resources, allowing developers to focus solely on specifying the desired state of resources based on current context.</p>"},{"location":"03-devguide/reconcilers/01_reconciler/#reconciler-outcomes","title":"Reconciler Outcomes","text":"<p>The actions a reconciler can take in response to events include:</p> <ul> <li>Done: The reconciler has completed its task with no further actions required.</li> <li>Requeue: The resource needs to be rechecked and possibly reconciled again in the near future.</li> <li>Requeue After: Similar to Requeue, but with a delay specified before the resource is reconsidered.</li> <li>Error: Indicates an issue during reconciliation; this typically leads to an implicit requeue unless handled otherwise.</li> <li>Fatal: A severe error that may require manual intervention or halt further automatic reconciliation under certain conditions.</li> </ul>"},{"location":"03-devguide/reconcilers/01_reconciler/#conflict-resolution","title":"Conflict resolution","text":"<p>To address potential conflicts between multiple reconcilers acting on the same resource, Choreo utilizes server-side apply logic. This approach ensures that each resource parameter is uniquely managed by a specific reconciler, thereby preventing operational overlap and conflicting modifications.</p> <p>Developer Considerations: A developper when designing the system has to ensure a resource parameter is only owned by a given reconciler</p>"},{"location":"03-devguide/reconcilers/02_config/","title":"Reconciler Config","text":"<p>In Choreo, a reconciler configuration is defined within a reconciler resource, where developers specify hooks and their respective parameters. This configuration determines how the reconciler interacts with the system\u2019s resources.</p> <pre><code>apiVersion: choreo.kform.dev/v1alpha1\nkind: Reconciler\n</code></pre>"},{"location":"03-devguide/reconcilers/02_config/#for-resource-hook","title":"For Resource hook","text":"<p>The for resource hook is mandatory and identifies the primary resource that the reconciler manages. It is sometimes referred to as the primary resource.</p> <pre><code>for: group: nf.nephio.org\nversion: v1alpha1\nkind: NFDeployment\nselector:\nmatch:\nspec.provider: upf.free5gc.io\n</code></pre> <p>Parameters:</p> <ul> <li>GVK (Group, Version, Kind): Identifies the for resource.</li> <li>Filters: Specify criteria to select specific resources for reconciliation. These filters use the CEL (Common Expression Language) functionality, allowing for complex logic across all resource fields, including lists and maps. Filters operate under a default-deny policy and require explicit whitelisting.</li> </ul>"},{"location":"03-devguide/reconcilers/02_config/#watch-resource-hook","title":"Watch resource hook","text":"<p>The watch resource hook is optional and used when a reconciler depends on external data or other resources for its logic. Changes in any watched resources specified in the reconciler configuration will trigger the reconciliation process for the associated primary resource.</p> <pre><code>  watches:\n- group: req.nephio.org\nversion: v1alpha1\nkind: Capacity\nselector:\nmatch:\nmetadata.name: upf\n</code></pre> <p>Parameters:</p> <ul> <li>GVK (Group, Version, Kind): Identifies the watch resource.</li> <li>Filters: Optional criteria to identify specific attributes that trigger the reconciliation process. These also operate under a default-deny policy and require whitelisting.</li> </ul>"},{"location":"03-devguide/reconcilers/02_config/#own-resource","title":"Own resource","text":"<p>Reconcilers may define own resources\u2014those they create, update, or delete as a result of their business logic. These resources are often referred to as child resources.</p> <pre><code>  owns:\n- group: req.kuid.dev\nversion: v1alpha1\nkind: Attachment\n</code></pre> <p>Parameters:</p> <pre><code>\u2022   GVK (Group, Version, Kind): Identifies the own resource.\n</code></pre> <p>When the business logic creates child resources it uses owner referernces and finalizers parameters on the child resources: - Owner References are used to track resources created by the reconciler, ensuring that dependency relationships are maintained. - Finalizers are used to allow the reconciler to perform necessary clean-up tasks before the child resource is fully removed from the system.</p> <p>Filtering mechanisms are omitted for owneed resources given there is an explicit parent relationship using onwer references.</p>"},{"location":"03-devguide/reconcilers/02_config/#reocnciler-config-example","title":"Reocnciler config example","text":"<p>Below is a practical example of how to define a reconciler configuration in <code>Choreo</code>. This configuration specifies how the reconciler interacts with various resources, utilizing the for, owns, and watches clauses to manage relationships and dependencies effectively.</p> <pre><code>apiVersion: choreo.kform.dev/v1alpha1\nkind: Reconciler\n# name can be inferred from the filename or from the for resource\nspec: for: group: nf.nephio.org\nversion: v1alpha1\nkind: NFDeployment\nselector:\nmatch:\nspec.provider: upf.free5gc.io\nowns:\n- group: req.kuid.dev\nversion: v1alpha1\nkind: Attachment\n- group: req.kuid.dev\nversion: v1alpha1\nkind: Prefix\nwatches:\n- group: req.nephio.org\nversion: v1alpha1\nkind: Capacity\nselector:\nmatch:\nmetadata.name: upf\n- group: req.nephio.org\nversion: v1alpha1\nkind: Interface\nselector:\nmatch:\nmetadata.name: n3\n- group: req.nephio.org\nversion: v1alpha1\nkind: Interface\nselector:\nmatch:\nmetadata.name: n4\n- group: req.nephio.org\nversion: v1alpha1\nkind: Interface\nselector:\nmatch:\nmetadata.name: n6\n</code></pre>"},{"location":"03-devguide/reconcilers/02_config/#filtering-example-using-cel-expressions","title":"filtering example using cel expressions","text":"<p>This example shows</p> <pre><code>    selector:\nmatch:\nstatus.conditions.exists(c, c.type == 'Ready' &amp;&amp; c.status == 'True'): \"true\"\n</code></pre>"},{"location":"03-devguide/reconcilers/03_gotemplate/","title":"Reconciler Using Go Templates","text":"<p>This chapter explains how to develop a reconciler using Go templates, powerful tools for transforming primary resources into child resources based on the input data. We will cover setting up the reconciler configuration and defining the business logic using Go templates.</p>"},{"location":"03-devguide/reconcilers/03_gotemplate/#reconciler-config","title":"Reconciler config","text":"<p>First, define the reconciler configuration. Go templates act as transformers that attach to a primary resource and generate a new child resource based on the input data. Specify the GVK (Group, Version, Kind) of both the primary and the child resources in your configuration. You can use additional filters to target transformations on resources with specific parameters.</p> <p>In the example below, only interfaces with spec.provider equal to srlinux.nokia.com will be transformed.</p> <pre><code>apiVersion: choreo.kform.dev/v1alpha1\nkind: Reconciler\n# name can be inferred from the filename or from the for resource\nspec: for: group: device.network.kubenet.dev\nversion: v1alpha1\nkind: Interface\nselector: match:\nspec.provider: srlinux.nokia.com\nowns:\n- group: config.sdcio.dev\nversion: v1alpha1\nkind: Config\n</code></pre> <p>Details:</p> <ul> <li>For Resource (for): Specifies the primary resource to which the reconciler attaches.</li> <li>Owns: Defines the type of child resource the reconciler will generate.</li> <li>Selector: Provides filtering capabilities to specify which resources with particular parameters will be transformed.</li> </ul>"},{"location":"03-devguide/reconcilers/03_gotemplate/#go-template-business-logic","title":"Go Template Business Logic","text":"<p>Next, define your reconciler\u2019s business logic as a Go template. The logic can be split across multiple files, but a main file ending with .main.tpl is required. Subsequent files can have any suffix and are referenced within the main template.</p> <p>We recommed using the following structure for the filenames:</p> <p><code>&lt;group&gt;.&lt;kind&gt;.&lt;name&gt;.&lt;suffix&gt;.tpl</code></p>"},{"location":"03-devguide/reconcilers/03_gotemplate/#example","title":"Example","text":"<p>Here\u2019s an example of a Go template that creates a Config resource from an Interface resource:</p> <p>Main template: device.kubenet.dev.interface.config.nokiasrl.main.tpl     - Group: device.kubenet.dev     - Kind: Interface     - Name: config.nokiasrl.main</p> <pre><code>apiVersion: config.sdcio.dev/v1alpha1\nkind: Config\nmetadata:\nname: {{ .metadata.name }}\nnamespace: {{ .metadata.namespace }}\nlabels:\nconfig.sdcio.dev/targetName: {{ .spec.node }}\nconfig.sdcio.dev/targetNamespace: {{ .metadata.namespace }}\nownerReferences:\n- apiVersion: {{ .apiVersion }}\ncontroller: true\nkind: {{ .kind }}\nname: {{ .metadata.name }}\nuid: {{ .metadata.uid }}\nspec:\npriority: 10\nconfig:\n- path: /\nvalue: {{- template \"srlinterface\" .spec}}\n</code></pre> <p>Sub Template: device.kubenet.dev.interface.config.nokiasrl.interface.tpl</p> <p>Here\u2019s an example of a sub-template defined in a separate file, which is referenced in the main template:</p> <pre><code>{{- define \"srlinterface\"}}\ninterface:\n- name: {{ .name }}\ndescription: k8s-{{ .name }}\nadmin-state: enable\n{{- if .vlanTagging}}\nvlan-tagging: true\n{{- end}}\n{{- end }}\n</code></pre> <p>Explanation:</p> <ul> <li>Metadata and Spec Configuration: Uses placeholders to dynamically set values based on the primary resource\u2019s properties.</li> <li>Template Call: {{- template \"srlinterface\" .spec}} calls a defined sub-template that sets additional configuration based on the Interface spec.</li> </ul> <p>Template-based reconcilers support modular and reusable logic, enabling developers familiar with this technology to efficiently leverage existing templates or adapt them for new applications.</p>"},{"location":"03-devguide/reconcilers/04_jinja2template/","title":"Reconciler Using Jinja2 Templates","text":"<p>This chapter explains how to develop a reconciler using Jinja2 templates, for transforming primary resources into child resources based on the input data. We will cover setting up the reconciler configuration and defining the business logic using Jinja2 templates.</p>"},{"location":"03-devguide/reconcilers/04_jinja2template/#reconciler-config","title":"Reconciler config","text":"<p>First, define the reconciler configuration. Jinja2 templates act as transformers that attach to a primary resource and generate a new child resource based on the input data. Specify the GVK (Group, Version, Kind) of both the primary and the child resources in your configuration. You can use additional filters to target transformations on resources with specific parameters.</p> <p>In the example below, only interfaces with spec.provider equal to srlinux.nokia.com will be transformed.</p> <pre><code>apiVersion: choreo.kform.dev/v1alpha1\nkind: Reconciler\n# name can be inferred from the filename or from the for resource\nspec: for: group: device.network.kubenet.dev\nversion: v1alpha1\nkind: Interface\nselector: match:\nspec.provider: srlinux.nokia.com\nowns:\n- group: config.sdcio.dev\nversion: v1alpha1\nkind: Config\n</code></pre> <p>Details:</p> <ul> <li>For Resource (for): Specifies the primary resource to which the reconciler attaches.</li> <li>Owns: Defines the type of child resource the reconciler will generate.</li> <li>Selector: Provides filtering capabilities to specify which resources with particular parameters will be transformed.</li> </ul>"},{"location":"03-devguide/reconcilers/04_jinja2template/#jinja2-template-business-logic","title":"Jinja2 Template Business Logic","text":"<p>Next, define your reconciler\u2019s business logic as a Jinja2 template. The logic can be split across multiple files, but a main file ending with .main.jinja2 is required. Subsequent files can have any suffix and are referenced within the main template.</p> <p>We recommed using the following structure for the filenames:</p> <p><code>&lt;group&gt;.&lt;kind&gt;.&lt;name&gt;.&lt;suffix&gt;.jinja2</code></p>"},{"location":"03-devguide/reconcilers/04_jinja2template/#example","title":"Example","text":"<p>Here\u2019s an example of a Go template that creates a Config resource from an Interface resource:</p> <p>Main template: device.kubenet.dev.interface.config.nokiasrl.main.jinja2     - Group: device.kubenet.dev     - Kind: Interface     - Name: config.nokiasrl.main</p> <pre><code>{%- import 'interface.jinja2' interface -%}\napiVersion: config.sdcio.dev/v1alpha1\nkind: Config\nmetadata:\nname: {{ metadata.name }}\nnamespace: {{ metadata.namespace }}\nlabels:\nconfig.sdcio.dev/targetName: {{ spec.node }}\nconfig.sdcio.dev/targetNamespace: {{ metadata.namespace }}\nownerReferences:\n- apiVersion: {{ apiVersion }}\ncontroller: true\nkind: {{ kind }}\nname: {{ metadata.name }}\nuid: {{ metadata.uid }}\nspec:\npriority: 10\nconfig:\n- path: /\nvalue: {{ interface(spec) -}} </code></pre> <p>Sub Template: device.kubenet.dev.interface.config.nokiasrl.interface.jinja2</p> <p>Here\u2019s an example of a sub-template defined in a separate file, which is referenced in the main template:</p> <pre><code>{%- macro interface(spec) export -%}\ninterface:\n- name: {{ spec.name }}\ndescription: k8s-{{ spec.name }}\nadmin-state: enable\n{%- if spec.vlanTagging %}\nvlan-tagging: true\n{%- endif %}\n{%- endmacro %}\n</code></pre> <p>Explanation:</p> <ul> <li>Metadata and Spec Configuration: Uses placeholders to dynamically set values based on the primary resource\u2019s properties.</li> <li>Template Call: {%- import 'interface.jinja2' interface -%} calls a defined sub-template that sets additional configuration based on the Interface spec.</li> </ul> <p>Template-based reconcilers support modular and reusable logic, enabling developers familiar with this technology to efficiently leverage existing templates or adapt them for new applications.</p>"},{"location":"04-examples/01_about/","title":"About","text":"<p>In the following repo you can find some choreo example to help you understand the concepts and scenario's </p> <p>choreo examples</p>"},{"location":"05-rn/rn/","title":"Kform release notes","text":"<p>We are stil in the early phases of our development, therefore we do not publish aggregated release notes for each of our releases. </p> <p>Release summaries are available on GitHub:</p> <ul> <li>Choreo</li> </ul>"},{"location":"06-community/01_about/","title":"Community","text":"<p>Join us in this jurney to build the power of 'KRM as code or data' to Kubernetes. We are happy to help and would like to learn your user stories in discord server.</p> <p>Choreo was started and currently maintained by Nokia with the clear target to make the project community driven.</p>"},{"location":"06-community/01_about/#kubenet","title":"Kubenet","text":"<p>If you are intrested in a biger picture about how do we imagine network automation in a Kubernetes native way check out Kubenet. </p>"},{"location":"06-community/01_about/#logos","title":"Logos","text":"<p>Logos of Kform in different formats:</p> <ul> <li>With name 100x123 png</li> <li>With name 503x690 png</li> <li>Without name 100x100 png</li> <li>With name svg</li> <li>Without name svg</li> </ul> <p></p>"}]}