{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Choreo is a KRM orchestration framework, leveraging the principles of kubernetes,  enabling the power of KRM as code or data. Choreo uses an event driven architecture that empowers flexible business logic</p> <p>With Choreo, orchestrating KRM resources becomes a easy through intuitive and human-readable configuration files. These files are not only reusable and shareable but can also be version-controlled, ensuring seamless collaboration among team members.</p> <p>At its core, Choreo empowers you to manage the entire lifecycle of KRM resources specified through the configuration files consistently. Whether it's deployment, scaling, or any other operation, Kform streamlines the process for any resource modeled as KRM. This framework is designed to enhance efficiency and maintainability, making Kubernetes resource orchestration a straightforward and manageable task.\"</p>"},{"location":"#why","title":"Why?","text":"<ul> <li>manage any KRM resource</li> <li>track changes     stored through the k8s api</li> <li>declarative     describe end state</li> <li>standardize     modules</li> <li>collaborate</li> </ul>"},{"location":"#join-us","title":"Join us","text":"<p>Have questions, ideas, bug reports or just want to chat? Come join to the Kform discord server.</p>"},{"location":"01-getting-started/01_getting_started/","title":"Getting Started","text":"<p>First check the prerequisites. </p>"},{"location":"01-getting-started/01_getting_started/#setup-environment","title":"Setup environment","text":"<p>This exercise will walk through a basic Hello world example. The API is already generated</p> <p>clone the choreo-examples git repo</p> <pre><code>git clone https://github.com/kform-dev/choreo-examples\n</code></pre> <p>Best to use 2 windows, one for the choreo server and one for the choreo client, since the choreo server will serve the system</p>"},{"location":"01-getting-started/01_getting_started/#choreo-server","title":"choreo server","text":"<p>start the choreoserver</p> <pre><code>choreoctl server start choreo-examples/hello-world/\n</code></pre> <p>The choreoserver support a version controlled backend but we dont explore this in this exercise.</p> <pre><code>{\"time\":\"2024-09-30T19:26:06.771564+02:00\",\"level\":\"INFO\",\"message\":\"server started\",\"logger\":\"choreoctl-logger\",\"data\":{\"name\":\"choreoServer\",\"address\":\"127.0.0.1:51000\"}}\nbranchstore update main oldstate &lt;nil&gt; -&gt; newstate CheckedOut\n</code></pre>"},{"location":"01-getting-started/01_getting_started/#choreo-client","title":"choreo client","text":"<p>With the following command we can explore the api(s) supported by the system. We see the helloworlds api being present, which got loaded when we started the server</p> <pre><code>choreoctl api-resources\n</code></pre> <pre><code>&amp;{upstreamrefs choreo.kform.dev v1alpha1 UpstreamRef  false [pkg knet]}\n&amp;{libraries choreo.kform.dev v1alpha1 Library  false [choreo]}\n&amp;{apiresources choreo.kform.dev v1alpha1 APIResources  true []}\n&amp;{configgenerators choreo.kform.dev v1alpha1 ConfigGenerator  false [pkg knet]}\n&amp;{customresourcedefinitions apiextensions.k8s.io v1 CustomResourceDefinition  false []}\n&amp;{reconcilers choreo.kform.dev v1alpha1 Reconciler  false [choreo]}\n&amp;{helloworlds example.com v1alpha1 HelloWorld HelloWorldList true []}\n</code></pre> <p>When executing the following command no result should be shown, since no hello world resources are loaded</p> <pre><code>choreoctl get customresourcedefinitions.apiextensions.k8s.io\n</code></pre> <p>Autocompletion should work, maybe try TAB completion iso copying the full command</p> <p>Now run the reconciler</p> <pre><code>choreoctl run once\n</code></pre> <p>you should see the reconciler <code>example.com.helloworlds.helloworld</code> being executed.</p> <pre><code>execution success, time(sec) 0.0031725\nReconciler                         Start Stop Requeue Error\nexample.com.helloworlds.helloworld     2    2       0     0\n</code></pre> <p>What just happened?</p> <p>a. the reconciler got loaded</p> HelloWorld Reconciler <pre><code>finalizer = \"helloworld.example.com/ready\"\nconditionType = \"Ready\"\ndef reconcile(self):\n# self = helloworld\nspec = self.get(\"spec\", {})\nspec[\"greeting\"] = \"hello choreo\"\nself['spec'] = spec\nreturn reconcile_result(self, False, 0, conditionType, \"\", False)\n</code></pre> <p>b. The reconciler registered to be informed on any HelloWorld resource change</p> <pre><code>    group: example.com\nversion: v1alpha1\nkind: HelloWorld\n</code></pre> HelloWorld Reconciler Hook <pre><code>apiVersion: choreo.kform.dev/v1alpha1\nkind: Reconciler\n# name can be inferred from the filename or from the for resource\nspec: for: group: example.com\nversion: v1alpha1\nkind: HelloWorld\nselector: {}\n</code></pre> <p>c. The reconciler business logic got triggered by adding this HelloWorld manifest</p> Hello World manifest <pre><code>apiVersion: example.com/v1alpha1\nkind: HelloWorld\nmetadata:\nname: test\nnamespace: default\n</code></pre> <p>let's see if it performed its job, by looking at the details of the HelloWorld manifest</p> <pre><code>choreoctl get helloworlds.example.com test -o yaml\n</code></pre> <p>We should see spec.greeting being changed to <code>hello choreo</code></p> <pre><code>apiVersion: example.com/v1alpha1\nkind: HelloWorld\nmetadata:\nannotations:\napi.choreo.kform.dev/origin: '{\"kind\":\"File\"}'\ncreationTimestamp: \"2024-09-30T17:49:34Z\"\ngeneration: 1\nname: test\nnamespace: default\nresourceVersion: \"1\"\nuid: deedbf64-b348-477e-9fbb-d2738ab4f3b0\nspec:\ngreeting: hello choreo\nstatus:\nconditions:\n- lastTransitionTime: \"2024-09-30T17:49:34Z\"\nmessage: \"\"\nreason: Ready\nstatus: \"True\"\ntype: Ready\n</code></pre> <p>\ud83c\udf89 You ran you first choreo reconciler. \ud83e\udd18</p> <p>Did you notice none of this required a kubernetes cluster? Choreo applies the kubernetes principles w/o imposing all the kubernetes container orchestration primitives.</p> <p>Try changing the business logic from <code>Hello Choreo</code> to <code>hello &lt;your name&gt;</code> and execute the business logic again</p> <pre><code>def reconcile(helloworld):\nspec = helloworld.get(\"spec\", {})\nspec[\"greeting\"] = \"hello wim\"\nhelloworld['spec'] = spec\nreturn reconcile_result(helloworld, False, 0, conditionType, \"\", False)\n</code></pre> <p>This should result in the following outcome if we run the business logic again.</p> <pre><code>choreoctl run once\n</code></pre> <pre><code>apiVersion: example.com/v1alpha1\nkind: HelloWorld\nmetadata:\nannotations:\napi.choreo.kform.dev/origin: '{\"kind\":\"File\"}'\ncreationTimestamp: \"2024-09-30T17:49:34Z\"\ngeneration: 1\nname: test\nnamespace: default\nresourceVersion: \"1\"\nuid: deedbf64-b348-477e-9fbb-d2738ab4f3b0\nspec:\ngreeting: hello wim\nstatus:\nconditions:\n- lastTransitionTime: \"2024-09-30T17:49:34Z\"\nmessage: \"\"\nreason: Ready\nstatus: \"True\"\ntype: Ready\n</code></pre> <p>You can also introduce an error and see what happens; e.g. change <code>greeting</code> to <code>greetings</code> which is an invalid json key in the schema.</p> <pre><code>def reconcile(helloworld):\nspec = helloworld.get(\"spec\", {})\nspec[\"greetings\"] = \"hello wim\"\nhelloworld['spec'] = spec\nreturn reconcile_result(helloworld, False, 0, conditionType, \"\", False)\n</code></pre> <p>when executing</p> <pre><code>choreoctl run once\n</code></pre> <p>the following result is obtained, indicating the schema error</p> <pre><code>execution failed example.com.helloworlds.helloworld.HelloWorld.example.com.test rpc error: code = InvalidArgument desc = fieldmanager apply failed err: failed to create typed patch object (default/test; example.com/v1alpha1, Kind=HelloWorld): .spec.greetings: field not declared in schema\n</code></pre>"},{"location":"01-getting-started/02_prereq/","title":"Prerequisites","text":""},{"location":"01-getting-started/02_prereq/#cpu-architecture","title":"CPU architecture","text":"<p>All the choreo components run on both AMD and ARM based CPU</p>"},{"location":"01-getting-started/02_prereq/#operating-system","title":"Operating system","text":"<p>We tested on WSL for windows and Linux and darwin OS.</p>"},{"location":"01-getting-started/02_prereq/#choreoctl","title":"choreoctl","text":"<p>Choreoctl is a command line tool for communicating with a Choreo server.</p> <p>choreoctl is a single binary built for linux and Mac OS, distributed via ghreleases. It</p> linux/Mac OSPackages <p>To download &amp; install the latest release the following automated installation script can be used.</p> <pre><code>bash -c \"$(curl -sL https://github.com/kform-dev/choreo/raw/main/install-choreoctl.sh)\"\n</code></pre> <p>As a result, the latest <code>choreoctl</code> version will be installed in the /usr/local/bin directory and the version information will be printed out.</p> <p>To install a specific version of <code>choreoctl</code>, provide the version with -v flag to the installation script:</p> <pre><code>bash -c \"$(curl -sL https://github.com/kform-dev/choreo/raw/main/install-choreoctl.sh)\" -- -v 0.0.1\n</code></pre> <p>Linux users running distributions with support for deb/rpm packages can install choreoctl using pre-built packages:</p> <pre><code>bash -c \"$(curl -sL https://github.com/kform-dev/choreo/raw/main/install-choreoctl.sh)\" -- --use-pkg\n</code></pre>"},{"location":"01-getting-started/02_prereq/#choreoctl-autocomplete","title":"choreoctl autocomplete","text":"bashzsh <pre><code>source &lt;(choreoctl completion bash) # set up autocomplete in bash into the current shell, bash-completion package should be installed first.\necho \"source &lt;(choreoctl completion bash)\" &gt;&gt; ~/.bashrc # add autocomplete permanently to your bash shell.\n</code></pre> <pre><code>source &lt;(choreoctl completion zsh)  # set up autocomplete in zsh into the current shell\necho '[[ $commands[choreoctl] ]] &amp;&amp; source &lt;(choreoctl completion zsh)' &gt;&gt; ~/.zshrc # add autocomplete permanently to your zsh shell\n</code></pre>"},{"location":"02-choreo/01_about/","title":"About","text":"<p>A Choreo project is a collection of resources in the form of <code>.yaml</code> or <code>.yml</code> stored in a directory. <code>Choreo</code> uses 3 main sub-directories in a package called <code>crds</code>, <code>in</code> and <code>refs</code>. </p> <ul> <li>The <code>crd</code> directory stores all the external API(s)</li> <li>The <code>in</code> directory stores all the <code>business logic</code> aka <code>programs</code> and <code>input data</code> associated with a project. </li> <li>The <code>refs</code> directory stores all the references to child choreo packages that can include additional <code>crds</code>, <code>business logic</code> or <code>data</code></li> </ul> <p><code>Choreo</code> always runs in the context of a single root package. A complete <code>Choreo</code> configuration consists of a root package and optionally a tree of child packages (if upstream references are referenced in the package)</p> <p>In <code>Choreo</code> CLI, the root package is the working directory where <code>Choreo</code> is invoked/pointed at.</p>"},{"location":"02-choreo/01_about/#apis-and-api-extensions","title":"APIs and API extensions","text":"<p>By using Custom resource definitions you can customize Choreo to orchestrate any use case. <code>CRDs</code> are stored in the <code>crd</code> directory of a choreo package and define the schema of the resource/api used to validate the resources consumed by the API. Choreo API is declarative </p>"},{"location":"02-choreo/01_about/#reconcilers","title":"Reconcilers","text":"<p>Reconcilers define the business logic associated to a resources. When defining a reconciler you define 2 things: - Which resources the reconciler is interested in. - The reconciler business logic. </p> <p>Reconcilers in choreo are built with a <code>low code no code</code> approach in mind to ease the adoption of the system.</p> <p>The following reconciler languages are supported: - starlark - gotemplates - jinja2 templates</p>"},{"location":"02-choreo/01_about/#libraries","title":"Libraries","text":"<p>To allow for more reusable  </p>"},{"location":"02-choreo/01_about/#upstreamrefs","title":"UpstreamRefs","text":"<p><code>Choreo</code> allows for reusable packages accross multiple project through the use of upstream refs. An upstream ref is basically a child <code>Choreo</code> instance of a root <code>Choreo</code> package. </p>"},{"location":"02-choreo/01_about/#data","title":"Data","text":"<p>Besides the built-in choreo apis, input data can also be provided in a choreo package. The input data, aligned with the API definitions, get invoked and will trigger the reconciler business logic defined in the <code>Choreo</code> instance.</p>"},{"location":"02-choreo/resources/01_apis/","title":"APIs","text":""},{"location":"02-choreo/resources/02_reconcilers/","title":"Reconcilers","text":""},{"location":"02-choreo/resources/03_libraries/","title":"Libraries","text":""},{"location":"02-choreo/resources/04_upstreamrefs/","title":"Upstream refs","text":""},{"location":"02-choreo/resources/05_data/","title":"Data","text":""},{"location":"03-userguide/01_about/","title":"About","text":"<p><code>Choreo</code> is an innovative tool designed to bridge the gap between development and production environments through a unified technology framework. Equipped with both server-side and client-side components, <code>Choreo</code> facilitates seamless transitions from development to production, making it an indispensable tool for dynamic application environments.</p>"},{"location":"03-userguide/01_about/#dual-environment-functionality","title":"Dual-Environment Functionality","text":"<p><code>Choreo</code> excels in both development (<code>dev</code>) and production (<code>prod</code>) settings. In development, users can evolve and update a base reference, continually refining their use cases with new data or business logic. In production, <code>Choreo</code> operates using a predefined reference, executing established logic with high reliability and consistency.</p>"},{"location":"03-userguide/01_about/#key-components","title":"Key Components","text":""},{"location":"03-userguide/01_about/#server","title":"server","text":"<p>The <code>Choreo</code> server can be initiated in two primary modes:</p> <ul> <li><code>User Mode</code>: This mode is tailored for users who prefer hands-on control over their project environments. Users manually clone a project and direct the Choreo server to the project directory upon startup. This mode fully supports version control operations, allowing users to commit, stash, push, and manage their changes using e.g. standard git commands. It is ideal for developers who need to interact directly with their codebase and version history.</li> <li><code>Choreo Mode</code>: Designed for automated efficiency, this mode enables the server to autonomously manage project directories. It clones repositories based on an immutable reference, suiting both manual interventions and automated processes. While it simplifies repository operations, it still supports a subset of essential version control functions, making it suitable for scenarios where streamlined, consistent deployments and updates are crucial.</li> </ul>"},{"location":"03-userguide/01_about/#runner","title":"runner","text":"<p><code>Choreo</code>\u2019s runner operates in two distinct modes, catering to different operational needs:</p> <ul> <li><code>Dev Mode</code>: Tailored for development tasks, this mode handles specific operations, executing them to completion and allowing for iterative testing and development. The dev mode is used to test new data input or changing reconciler logic.</li> <li><code>Prod Mode</code>: Designed for production, this mode enables the runner to continuously process and react to events with its built-in reconciler logic, ideal for monitoring and observing ongoing activities within the environment.</li> </ul>"},{"location":"03-userguide/01_about/#result-manager","title":"result manager","text":"<p>Results from operations are meticulously captured in conditions and stored in snapshots at the end of each run, providing a persistent and immutable record of system states and data outputs. In continuous prod mode, the server must be stopped to finalize and store results, facilitating comprehensive comparisons through diffs between successive runs.</p> <p>More details will be explained in the respective sections of the user guide.</p>"},{"location":"03-userguide/02_server/","title":"Choreo Server","text":"<p>The Choreo server initiates with two distinct operational modes: User Mode and Choreo Mode. Each mode is designed to support various development and production needs, ranging from full user control to automated environment management.</p> <ul> <li>User Mode: Provides developers with full control over the project environment, allowing direct interaction with the repository and its version control systems.</li> <li>Choreo Mode: Automates project management tasks, enabling dynamic context management with minimal user intervention.</li> </ul> <p>These modes enable tailored workflows, accommodating both hands-on development practices and streamlined, automated operations for production environments.</p>"},{"location":"03-userguide/02_server/#starting-the-server","title":"Starting the server","text":"<p>To start the Choreo server, use the following command format:</p> <pre><code>choreo server start [DIRECTORY] [flags]\n</code></pre> <p>The presence of a directory argument in the command determines the operational mode of the server:</p> <ul> <li>User Mode: Specify the directory to activate this mode.</li> <li>Choreo Mode: Omit the directory to operate in Choreo Mode.</li> </ul>"},{"location":"03-userguide/02_server/#user-mode","title":"User Mode","text":""},{"location":"03-userguide/02_server/#overview","title":"Overview","text":"<p>In <code>User Mode</code>, the user manually clones a repository and points the Choreo server to either the cloned directory or a subdirectory within it. This mode is primarily used for development, where developers require full control over the version control operations.</p>"},{"location":"03-userguide/02_server/#operations","title":"Operations","text":"<p>To start the server in User Mode, specify the directory path:</p> <pre><code>choreo server start [DIRECTORY] [flags]\n</code></pre> <p>In this mode, the context of the server is fixed to the specified directory, but the user retains the ability to use all version control commands, such as commit, stash, and push. This facilitates an interactive development process where changes can be directly managed and integrated.</p>"},{"location":"03-userguide/02_server/#choreo-mode","title":"Choreo Mode","text":""},{"location":"03-userguide/02_server/#overview_1","title":"Overview","text":"<p>Choreo Mode allows the server to dynamically manage the project\u2019s context. When provided with a repository URL, directory path, and reference, the server autonomously handles the cloning and setup of the repository in a specific directory. This mode supports both development and production environments.</p>"},{"location":"03-userguide/02_server/#operations_1","title":"Operations","text":"<p>To configure the server in Choreo Mode, use the apply command with the necessary repository details:</p> <pre><code>choreo server apply [URL] [DIR] [REF] [BRANCH]\n</code></pre>"},{"location":"03-userguide/02_server/#mode-differentiation","title":"Mode Differentiation","text":"<ul> <li>Development Environment: Specify a branch to indicate that the server should operate in development mode. In this mode, the user or automated systems can instruct the server when to run operations, commit changes, push updates, and create diffs.</li> <li>Production Environment: Omit the branch to default to production mode, typically using the main branch. In this setting, the server operates in a continuous mode, executing the reconciliation logic referenced in the project</li> </ul>"},{"location":"03-userguide/02_server/#dynamic-context-switching","title":"Dynamic Context Switching","text":"<p>you can switch context to the server using the following comamnd. We don`t expect people to switch between production or development, but e.g. in production we can change the reference to rollback to a previous reference that was more stable or to move to a new reference that was validated. In development we will see people commiting chnages to a new branch for new changes to the repo.</p> <pre><code>choreo server apply [URL] [DIR] [REF] [BRANCH]\n</code></pre>"},{"location":"03-userguide/02_server/#status-retrieval","title":"Status Retrieval","text":"<p>To retrieve the current status or configuration of the server, use the get command:</p> <pre><code>choreo server get\n</code></pre> <p>This command is essential for monitoring and managing the server\u2019s state, ensuring transparency and control over the ongoing processes.</p>"},{"location":"03-userguide/03_runner/","title":"Runner","text":"<p>The Choreo runner operates as the execution engine of the platform, capable of running in two distinct modes: Development Mode and Production Mode. These modes are tailored to support different stages of project development and deployment, ensuring both flexibility and robustness in handling resources and executing business logic.</p>"},{"location":"03-userguide/03_runner/#resources","title":"Resources","text":"<p>Choreo is fundamentally an API-first system, utilizing Kubernetes Resource Model (KRM) Custom Resource Definitions (CRDs) as APIs to manage and interact with resources. When the runner is initiated, it loads CRDs and input data from associated directories in the Choreo server. Following data initialization, reconcilers are instantiated to execute their business logic based on the updated resources in the system. This setup leverages a list and watch mechanism, allowing reconcilers to trigger and operate based on the initial loaded data.</p>"},{"location":"03-userguide/03_runner/#development-mode","title":"Development mode","text":""},{"location":"03-userguide/03_runner/#purpose","title":"Purpose","text":"<p>Development mode is designed for testing and validation, ideal for developers looking to verify new data inputs, API functionalities, or business logic changes. This mode provides an iterative environment where changes can be applied, tested, and observed in a controlled setting.</p>"},{"location":"03-userguide/03_runner/#operation","title":"Operation","text":"<p>In Development Mode, the runner operates on a single-run basis, executing the following steps:</p> <ol> <li>Initialization: Loads CRDs and input data into the system.</li> <li>Execution: Starts the reconcilers which consume the data.</li> <li>Observation: An observer component monitors the execution process, assessing outcomes based on various indicators such as error messages, condition statuses, and event triggers.</li> </ol>"},{"location":"03-userguide/03_runner/#completion","title":"Completion","text":"<p>The process concludes when the observer determines the success or failure of the run. The results are then presented to the developer, facilitating quick feedback and iteration.</p> <pre><code>choreoctl run once\n</code></pre>"},{"location":"03-userguide/03_runner/#production-mode","title":"Production mode","text":""},{"location":"03-userguide/03_runner/#purpose_1","title":"Purpose","text":"<p>Production mode is designed for continuous operation, when you decided the input data and business logic is suitable for produciton.</p>"},{"location":"03-userguide/03_runner/#operation_1","title":"Operation","text":"<p>In Production Mode, the runner continuously processes and reacts to changes in the environment, driven by event triggers and updates to the resources:</p> <ol> <li>Start: Initializes and begins continuous processing.</li> <li>Running: Maintains ongoing observation and response to resource changes and system events.</li> <li>Management: Allows for stopping and starting of operations to manage updates or maintenance tasks effectively.</li> </ol> <p>start the server in continuous mode</p> <pre><code>choreoctl run start\n</code></pre> <p>stop the server</p> <pre><code>choreoctl run stop\n</code></pre>"},{"location":"03-userguide/04_results/","title":"Results","text":"<p>In Choreo, results management is intricately designed to cater to both development and production environments, leveraging logs and API interactions to monitor and understand the status and output of operations.</p>"},{"location":"03-userguide/04_results/#production","title":"Production","text":"<p>In a production setting, users/machines can consult logs or interact directly with the API server to check the status of resources. This provides a real-time insight into the system\u2019s operational status, helping identify any issues or confirm the health of the processes.</p>"},{"location":"03-userguide/04_results/#development","title":"Development","text":"<p>The development environment is enhanced with additional tools to aid in testing and troubleshooting:</p> <ul> <li>Observer Insights: The observer component plays a critical role in development mode by informing users about the success or failure of each run. This immediate feedback is crucial for iterative development and troubleshooting.</li> <li>Snapshot Storage: Upon a successful run, a snapshot of the data produced during that operation is stored. This allows developers to capture and review the state of the system at the time of execution, which is invaluable for debugging and historical analysis.</li> </ul>"},{"location":"03-userguide/04_results/#managing-results-with-choreo-commands","title":"Managing Results with Choreo Commands","text":""},{"location":"03-userguide/04_results/#running-and-observing-operations","title":"Running and Observing Operations","text":"<p>To initiate a run and observe the results in development mode, use the following command:</p> <pre><code>choreoctl run once\n</code></pre> <p>This command executes the operational logic once and provides an output summarizing the execution:</p> <pre><code>execution success, time(sec) 0.019575833\nReconciler                                       Start Stop Requeue Error\nnf.nephio.org.nfdeployments.upf.free5gc.io.claim     2    2       0     0\nnf.nephio.org.nfdeployments.upf.free5gc.io.ready     1    1       0     0\n...\n</code></pre>"},{"location":"03-userguide/04_results/#analyzing-changes-with-snapshots","title":"Analyzing Changes with Snapshots","text":"<p>Developers can compare current results with previous snapshots to understand the impact of changes:</p> <pre><code>choreoctl run diff\n</code></pre> <p>This command outputs a detailed list of changes between the current and previous runs, helping identify new or altered resources:</p> <pre><code>+ infra.kuid.dev/v1alpha1, Kind=Cluster nephio.region1.us-east.cluster1\n+ infra.kuid.dev/v1alpha1, Kind=Cluster nephio.region2.us-west.cluster1\n...\n</code></pre> <p>Snapshot Options</p> <p>Choreo also provides options to enhance the detail level in snapshot comparisons:</p> <ul> <li>-i option: Includes internal Choreo API states in the diff.</li> <li>-a option: Displays detailed attributes of each element.</li> <li>-m option: Shows managed fields details, providing deeper insights into what has changed and why.</li> </ul> <p>example with -a option</p> <pre><code>choreoctl run diff\n</code></pre> <p>output</p> <pre><code>+ req.nephio.org/v1alpha1, Kind=DataNetwork nephio.internet.ipv4\n  map[string]any(\n-       nil,\n+       {\n+               \"apiVersion\": string(\"req.nephio.org/v1alpha1\"),\n+               \"kind\":       string(\"DataNetwork\"),\n+               \"metadata\": map[string]any{\n+                       \"annotations\":       map[string]any{\"api.choreo.kform.dev/origin\": string(`{\"kind\":\"File\"}`)},\n+                       \"creationTimestamp\": string(\"2024-10-11T07:03:25Z\"),\n+                       \"finalizers\":        []any{string(\"req.nephio.org.dnns.claim\"), string(\"req.nephio.org.dnns.ready\")},\n+                       \"name\":              string(\"nephio.internet.ipv4\"),\n+                       \"namespace\":         string(\"default\"),\n+                       \"resourceVersion\":   string(\"2\"),\n+                       \"uid\":               string(\"387b5e9d-acb9-4c08-9b95-8cc8239a87e6\"),\n+               },\n+               \"spec\": map[string]any{\"network\": string(\"vpc-internet\"), \"pools\": []any{map[string]any{...}}},\n+               \"status\": map[string]any{\n+                       \"conditions\": []any{map[string]any{...}, map[string]any{...}},\n+                       \"pools\":      []any{map[string]any{...}},\n+               },\n+       },\n  )\n</code></pre>"},{"location":"03-userguide/04_results/#viewing-dependencies","title":"Viewing Dependencies","text":"<p>Understanding dependencies between resources is critical for managing complex systems. Choreo facilitates this with visualization commands that delineate how resources are interconnected:</p> <pre><code>choreoctl deps\n</code></pre> <p>This functionality not only aids in troubleshooting but also helps in planning and verifying system architecture integrity.</p> <pre><code>...\nNFDeployment.nf.nephio.org/v1alpha1 nephio.region1.us-east1.cluster1.upf1\n+-Attachment.req.kuid.dev/v1alpha1 nephio.region1.us-east1.cluster1.upf1.n3\n+-Attachment.req.kuid.dev/v1alpha1 nephio.region1.us-east1.cluster1.upf1.n4\n+-Attachment.req.kuid.dev/v1alpha1 nephio.region1.us-east1.cluster1.upf1.n6\n...\n</code></pre> <p>you can see that NFDeployment.nf.nephio.org/v1alpha1 nephio.region1.us-east1.cluster1.upf1 has 3 children:</p> <ul> <li>Attachment.req.kuid.dev/v1alpha1 nephio.region1.us-east1.cluster1.upf1.n3</li> <li>Attachment.req.kuid.dev/v1alpha1 nephio.region1.us-east1.cluster1.upf1.n4</li> <li>Attachment.req.kuid.dev/v1alpha1 nephio.region1.us-east1.cluster1.upf1.n6</li> </ul>"},{"location":"03-userguide/05_datachanges/","title":"Data input changes","text":"<p>use files in the repo</p> <p>use choreoctl apply</p>"},{"location":"04-devguide/01_about/","title":"Developper guide","text":"<p>The developper guide is designed to help developers extend Choreo with custom APIs and custom business logic (reconcilers) for their use cases.</p>"},{"location":"04-devguide/01_about/#apis","title":"APIs","text":"<p>At the heart of <code>Choreo</code> are its APIs, which are implemented using Custom Resource Definitions (CRDs). These CRDs extend Choreo\u2019s native capabilities, allowing developers to define custom resources specific to their needs. Each API in Choreo is designed to be self-descriptive and aligned with standard KRM practices, ensuring ease of use and integration.</p>"},{"location":"04-devguide/01_about/#reconcilers","title":"Reconcilers","text":"<p>Reconcilers are another pivotal component of <code>Choreo</code>. They attach to a resource in Choreo and react to resource changes triggering necessary updates and adjustments based on their business logic. Choreo support the following reconciler types</p> <ul> <li>go template</li> <li>jinja2 template</li> <li>python/starlark</li> </ul>"},{"location":"04-devguide/apis/01_crd/","title":"API(s)","text":"<p>Choreo adopts an API-first approach, fundamentally leveraging the Kubernetes Resource Model (KRM) as defined by Kubernetes. In this system, each API object represents a resource that Choreo imports using Custom Resource Definitions (CRDs). CRDs allow for the extension of Choreo's capabilities by defining new resource types with associated schemas.</p>"},{"location":"04-devguide/apis/01_crd/#defining-a-crd","title":"Defining a CRD","text":"<p>You can create a CRD in various ways:</p> <ul> <li>manually</li> <li>kubebuilder</li> <li>others: TBD </li> </ul> <p>Each CRD includes several critical pieces of metadata that define how the resource interacts with the API Server:</p> <ul> <li>Group: The API group to which the CRD belongs, helping to categorize and control API extensions.</li> <li>Kind: The type of the resource, which is typically a descriptive name in CamelCase.</li> <li>Version: Indicates the version of the API which can evolve over time.</li> <li>Scope: Determines whether the resource is Namespaced (available within specific namespaces) or Cluster-scoped (available across all namespaces).</li> <li>Names: Includes the plural, singular, and optionally short names used in API requests and user interfaces.</li> </ul>"},{"location":"04-devguide/apis/01_crd/#crd-example","title":"CRD example","text":"<p>Here is an example of a CRD definition for a custom resource named \u201cCronTab\u201d:</p> <pre><code>apiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n# name must match the spec fields below, and be in the form: &lt;plural&gt;.&lt;group&gt;\nname: crontabs.stable.example.com\nspec:\n# group name to use for REST API: /apis/&lt;group&gt;/&lt;version&gt;\ngroup: stable.example.com\n# list of versions supported by this CustomResourceDefinition\nversions:\n- name: v1\n# Each version can be enabled/disabled by Served flag.\nserved: true\n# One and only one version must be marked as the storage version.\nstorage: true\nschema:\nopenAPIV3Schema:\ntype: object\nproperties:\nspec:\ntype: object\nproperties:\ncronSpec:\ntype: string\nimage:\ntype: string\nreplicas:\ntype: integer\n# either Namespaced or Cluster\nscope: Namespaced\nnames:\n# plural name to be used in the URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;\nplural: crontabs\n# singular name to be used as an alias on the CLI and for display\nsingular: crontab\n# kind is normally the CamelCased singular type. Your resource manifests use this.\nkind: CronTab\n# shortNames allow shorter string to match your resource on the CLI\nshortNames:\n- ct\n</code></pre> <p>Key Components of a CRD:</p> <ul> <li>API Version and Kind: Identifies the CRD in the context of the Kubernetes API.</li> <li>Metadata Name: Specifies the name of the CRD in a format .. <li>Spec: Defines the group, versions, and scope of the CRD, including the schema used to validate each version.</li> <li>OpenAPI Schema     Embedded within the CRD is an openAPIV3Schema which specifies the structure and validation rules of the resource. This schema ensures that all instances of the resource conform to the defined specifications, such as required fields, field types, and additional metadata.</li>"},{"location":"04-devguide/apis/01_crd/#crd-usage-in-choreo","title":"CRD Usage in Choreo","text":"<p>In Choreo a CRD is stored in the crd folder of a project and will be imported when the choreo server starts. Once loaded CRUD operations can be performed on these resources.</p>"},{"location":"04-devguide/apis/02_kubebuilder/","title":"Generating crds using kubebuilder","text":"<p>Kubebuilder is a suite that simplifies building Kubernetes APIs using custom resource definitions (CRDs). It leverages Go structs along with controller-runtime annotations to automate and enhance the development process.</p>"},{"location":"04-devguide/apis/02_kubebuilder/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure that Go is installed on your system. You can install Go by following the instructions here: Install go</p>"},{"location":"04-devguide/apis/02_kubebuilder/#setting-up-your-project","title":"Setting Up Your Project","text":"<p>This section demonstrates setting up a basic project structure manually. Typically, this is scaffolded.</p>"},{"location":"04-devguide/apis/02_kubebuilder/#initialize-the-project","title":"Initialize the Project","text":"<p>Create and navigate into a new project directory:</p> <pre><code>mkdir &lt;project-name&gt;; cd &lt;project-name&gt;\nmkdir -p apis/\n</code></pre> <p>initialize the go project</p> <pre><code>go mod init github.com/dummy/test\n</code></pre>"},{"location":"04-devguide/apis/02_kubebuilder/#prepare-the-makefile","title":"Prepare the Makefile","text":"<pre><code>touch Makefile\n</code></pre> <pre><code>## Location to install dependencies to\nLOCALBIN ?= $(shell pwd)/bin\n$(LOCALBIN):\n    mkdir -p $(LOCALBIN)\n## Tool Binaries\nCONTROLLER_GEN ?= $(LOCALBIN)/controller-gen\nCONTROLLER_TOOLS_VERSION ?= v0.15.0\n\n# Setting SHELL to bash allows bash commands to be executed by recipes.\n# Options are set to exit when a recipe line exits non-zero or a piped command fails.\nSHELL = /usr/bin/env bash -o pipefail\n.SHELLFLAGS = -ec\n\n.PHONY: manifests\n\nall: manifests\n\n.PHONY: manifests\nmanifests: controller-gen ## Generate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects.\nmkdir -p artifacts\n    $(CONTROLLER_GEN) rbac:roleName=manager-role crd paths=\"./apis/...\" output:crd:artifacts:config=crds\n\n.PHONY: controller-gen\ncontroller-gen: $(CONTROLLER_GEN) ## Download controller-gen locally if necessary.\n$(CONTROLLER_GEN): $(LOCALBIN)\ntest -s $(LOCALBIN)/controller-gen || GOBIN=$(LOCALBIN) go install sigs.k8s.io/controller-tools/cmd/controller-gen@$(CONTROLLER_TOOLS_VERSION)\n</code></pre>"},{"location":"04-devguide/apis/02_kubebuilder/#generate-manifests","title":"Generate Manifests","text":"<pre><code>make manifests\n</code></pre>"},{"location":"04-devguide/apis/02_kubebuilder/#creating-your-first-api","title":"Creating Your First API","text":"<p>create a directory where we store your api artifacts</p> <pre><code>mkdir -p apis/foo/v1alpha1\n</code></pre> <p>create a doc.go file and the test_types.go file containing the api</p> <pre><code>touch apis/foo/v1alpha1/doc.go\ntouch apis/foo/v1alpha1/test_types.go\n</code></pre> <pre><code>// +kubebuilder:object:generate=true\n// +groupName=foo.example.com\n// Package v1alpha1 is the v1alpha1 version of the API.\npackage v1alpha1\n</code></pre> <pre><code>package v1alpha1\nimport (\nmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n// TestSpec defines the desired state of the Test resource\ntype TestSpec struct {\n}\n// TestStatus defines the observed state of the Test resource\ntype TestStatus struct {\n}\n// +kubebuilder:object:root=true\n// +kubebuilder:subresource:status\n// Test is the Schema for the Test API\ntype Test struct {\nmetav1.TypeMeta   `json:\",inline\"`\nmetav1.ObjectMeta `json:\"metadata,omitempty\"`\nSpec   TestSpec   `json:\"spec,omitempty\"`\nStatus TestStatus `json:\"status,omitempty\"`\n}\n// TestList contains a list of Tests\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\ntype TestList struct {\nmetav1.TypeMeta `json:\",inline\" yaml:\",inline\"`\nmetav1.ListMeta `json:\"metadata,omitempty\"`\nItems           []Test `json:\"items\"`\n}\n</code></pre> <p>run go mod tidy to resolve the dependencies</p> <pre><code>go mod tidy\n</code></pre> <p>generate your api</p> <pre><code>make manifests\n</code></pre>"},{"location":"04-devguide/apis/02_kubebuilder/#adding-parameters-with-validation","title":"Adding parameters with validation","text":"<p>crd generation</p> <p>crd validation</p> <pre><code>type TestSpec struct {\n// +kubebuilder:validation:MaxLength=15\n// +kubebuilder:validation:MinLength=3\n// FieldA defines the name of field A\nFieldA string `json:\"fieldA,omitempty\"`\n}\n</code></pre> <p>create an object with an empty fieldA in spec -&gt; acceppted</p> <pre><code>choreoctl apply &lt;&lt;EOF\napiVersion: foo.example.com/v1alpha1\nkind: Test\nmetadata:\nname: my-first-test\nspec:\nEOF\n</code></pre> <p>create an object with a fieldA but with 1 char in spec -&gt; rejected</p> <pre><code>choreoctl apply - &lt;&lt;EOF\napiVersion: foo.example.com/v1alpha1\nkind: Test\nmetadata:\nname: my-first-test\nspec:\nfieldA: w\nEOF\n</code></pre> <p>create an object with a fieldA but with 3 char in spec -&gt; accepted</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: foo.example.com/v1alpha1\nkind: Test\nmetadata:\nname: my-first-test\nspec:\nfieldA: wim\nEOF\n</code></pre>"},{"location":"04-devguide/apis/02_kubebuilder/#examples-of-additional-parameters-with-constraints","title":"Examples of additional parameters with constraints","text":"<pre><code>type TestSpec struct {\n// +kubebuilder:validation:MaxItems=2\n// ListA defines a list of A\nListA []string `json:\"listA,omitempty\"`\n// +kubebuilder:validation:Enum=unknown;gnmi;netconf;noop;ssh;\n// +kubebuilder:default:=\"gnmi\"\n// Protocol defines the protocol to connect to the device\nProtocol string `json:\"protocol\"`\n// +kubebuilder:validation:Pattern=`(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))`\n// Address defines the ip address to connect to the host\nAddress string `json:\"address\"`\n// +kubebuilder:validation:Minimum=1\n// +kubebuilder:validation:Maximum=200\n// +kubebuilder:default:=100\nPriority   *uint8 `json:\"priority,omitempty\"`\n}\n</code></pre>"},{"location":"04-devguide/reconcilers/01_reconciler_hooks/","title":"Reconciler hooks","text":"<p>In Choreo, reconcilers are critical components that synchronize the desired state of resources with their actual state in the system. They are tightly integrated with the API server, responding to changes in resources and executing their respective business logic.  </p>"},{"location":"04-devguide/reconcilers/01_reconciler_hooks/#reconciler-attachments","title":"Reconciler Attachments","text":"<p>Reconcilers are attached to specific resources within Choreo using event handlers, and they operate based on several key principles:</p> <ul> <li>For Resource: This is the primary resource that the reconciler manages directly. Each instance of this resource is handled in its own Go routine, ensuring isolated and efficient management.</li> <li>Watch Resource: These are the resources that the reconciler depends on for executing its logic. Changes in these resources can trigger the reconciler to act on the primary resource.</li> <li>Own Resource: These are resources that the reconciler creates as a result of its operations. Managing these resources involves tracking dependencies and cleanup via owner references and finalizers.</li> </ul> <p>Reconcilers are designed to be idempotent and language-agnostic, allowing for diverse implementation strategies and ease of use.</p>"},{"location":"04-devguide/reconcilers/01_reconciler_hooks/#configuration-of-reconcilers","title":"Configuration of Reconcilers","text":""},{"location":"04-devguide/reconcilers/01_reconciler_hooks/#for-resource","title":"For Resource","text":"<p>The primary resource for a reconciler is specified with mandatory fields that define what resource it manages:</p> <pre><code>for: group: nf.nephio.org\nversion: v1alpha1\nkind: NFDeployment\nselector:\nmatch:\nspec.provider: upf.free5gc.io\n</code></pre> <ul> <li>Mandatory Configuration: The reconciler is attached to a single resource type, and changes to any instance of this resource can trigger the reconciler.</li> <li>Filters: Filters can be applied to select specific resources based on any field within the resource. Filters are implemented using cel functionality to allow for very flexible filtering logic.</li> </ul>"},{"location":"04-devguide/reconcilers/01_reconciler_hooks/#watch-resource","title":"Watch resource","text":"<p>Watching resources is optional but crucial for reconcilers that rely on external data or dependencies:</p> <ul> <li>Trigger Mechanism: A change in any watched resource can initiate a reconciliation process for the associated primary resource.</li> <li>Dependency Management: This setup allows a reconciler to monitor resources that impact its logic or outcomes.</li> </ul> <pre><code>  watches:\n- group: req.nephio.org\nversion: v1alpha1\nkind: Capacity\nselector:\nmatch:\nmetadata.name: upf\n</code></pre> <p>Watch resources allow for the extensive filtering mechanism</p>"},{"location":"04-devguide/reconcilers/01_reconciler_hooks/#own-resource","title":"Own resource","text":"<p>Managing owned resources involves utilizing KRM features like owner references and finalizers:</p> <ul> <li>Owner References: These are used to track resources created by the reconciler, ensuring that dependency relationships are maintained.</li> <li>Finalizers: Utilized to clean up resources when they are deleted, allowing the reconciler to perform necessary clean-up tasks before the resource is fully removed from the system.</li> </ul> <pre><code>  owns:\n- group: req.kuid.dev\nversion: v1alpha1\nkind: Attachment\n</code></pre> <p>Filtering mechanisms are omitted for owneed resources given there is an explicit parent relationship using onwer references.</p>"},{"location":"04-devguide/reconcilers/01_reconciler_hooks/#reconciler-outcomes","title":"Reconciler Outcomes","text":"<p>The actions a reconciler can take in response to events include:</p> <ul> <li>Done: The reconciler has completed its task with no further actions required.</li> <li>Requeue: The resource needs to be rechecked and possibly reconciled again in the near future.</li> <li>Requeue After: Similar to Requeue, but with a delay specified before the resource is reconsidered.</li> <li>Error: Indicates an issue during reconciliation; this typically leads to an implicit requeue unless handled otherwise.</li> <li>Fatal: A severe error that may require manual intervention or halt further automatic reconciliation under certain conditions.</li> </ul>"},{"location":"04-devguide/reconcilers/01_reconciler_hooks/#conflict-resolution","title":"Conflict resolution","text":"<p>Choreo employs server-side apply logic to resolve conflicts between reconcilers acting on the same resource. This ensures that each parameter of a resource is uniquely managed by a specific reconciler, avoiding overlap and conflicting operations.</p>"},{"location":"04-devguide/reconcilers/01_reconciler_hooks/#simplifying-implementation","title":"Simplifying implementation","text":"<p>Managing the complete lifecycle of resources\u2014such as creation, updates, and cleanup\u2014can be complex, often requiring developers to handle intricate historical data and state changes. Choreo simplifies this aspect of reconciler implementation by abstracting the historical management of resources, allowing developers to focus solely on specifying the desired state of resources based on current context.</p>"},{"location":"04-devguide/reconcilers/01_reconciler_hooks/#example","title":"Example","text":"<p>Below is a practical example of how to define a reconciler configuration in Choreo. This configuration specifies how the reconciler interacts with various resources, utilizing the for, owns, and watches clauses to manage relationships and dependencies effectively.</p> <pre><code>apiVersion: choreo.kform.dev/v1alpha1\nkind: Reconciler\n# name can be inferred from the filename or from the for resource\nspec: for: group: nf.nephio.org\nversion: v1alpha1\nkind: NFDeployment\nselector:\nmatch:\nspec.provider: upf.free5gc.io\nowns:\n- group: req.kuid.dev\nversion: v1alpha1\nkind: Attachment\n- group: req.kuid.dev\nversion: v1alpha1\nkind: Prefix\nwatches:\n- group: req.nephio.org\nversion: v1alpha1\nkind: Capacity\nselector:\nmatch:\nmetadata.name: upf\n- group: req.nephio.org\nversion: v1alpha1\nkind: Interface\nselector:\nmatch:\nmetadata.name: n3\n- group: req.nephio.org\nversion: v1alpha1\nkind: Interface\nselector:\nmatch:\nmetadata.name: n4\n- group: req.nephio.org\nversion: v1alpha1\nkind: Interface\nselector:\nmatch:\nmetadata.name: n6\n</code></pre>"},{"location":"06-rn/rn/","title":"Kform release notes","text":"<p>We are stil in the early phases of our development, therefore we do not publish aggregated release notes for each of our releases. </p> <p>Release summaries are available on GitHub:</p> <ul> <li>Kform</li> </ul>"},{"location":"07-community/01_about/","title":"Community","text":"<p>Join us in this jurney to build the power of 'KRM as code or data' to Kubernetes. We are happy to help and would like to learn your user stories in the Kubenet discord server.</p> <p>Kform was started and currently maintained by Nokia with the clear target to make the project community driven.</p>"},{"location":"07-community/01_about/#kubenet","title":"Kubenet","text":"<p>If you are intrested in a biger picture about how do we imagine network manegement in a Kubernetes native way check out Kubenet. </p>"},{"location":"07-community/01_about/#logos","title":"Logos","text":"<p>Logos of Kform in different formats:</p> <ul> <li>With name 100x123 png</li> <li>With name 503x690 png</li> <li>Without name 100x100 png</li> <li>With name svg</li> <li>Without name svg</li> </ul> <p></p>"}]}