{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Choreo","text":"<p>Choreo is an advanced open-source orchestration framework designed to simplify and enhance how you automate and orchestrate systems. Built on the principles of Kubernetes and leveraging the Kubernetes Resource Model (KRM), it utilizes an event-driven and declarative approach to automation. This versatile platform empowers teams to manage a broad spectrum of systems and processes, including lifecycle management, provisioning, configuration, and application deployment. As a freely available tool, Choreo thrives on the collective expertise and innovation contributed by its vibrant community.</p>"},{"location":"#key-features-of-choreo","title":"Key Features of Choreo","text":"<p>Choreo integrates a range of features designed to streamline operations and foster collaboration, making it a versatile tool for any environment:</p> <ul> <li>Bring Your Own Schema/API: Customization at Your Fingertips: Choreo allows you to integrate your own schemas or APIs, enabling seamless tailoring of the orchestration framework to meet your specific requirements.</li> <li>Service Catalog: Ready-to-Deploy Solutions: Access a rich service catalog offering a variety of pre-defined templates and configurations. This feature speeds up deployment and ensures that best practices are easily adopted.</li> <li>Modular Business Logic: Build As You Go: The framework supports modular business logic, which facilitates easy extensions and adaptations throughout the lifecycle of your projects.</li> <li>Low Code/No Code: Accessibility for Everyone: Choreo\u2019s low-code/no-code capabilities ensure that high levels of automation are achievable without deep coding knowledge, making advanced orchestration accessible to a broader audience.</li> <li>Collaborative Change Management: Streamlined Teamwork: With robust tools for collaborative change management, Choreo ensures that teams can work together efficiently. Changes are easy to track, manage, and review, enhancing transparency and reducing the risk of conflicts or errors.</li> </ul>"},{"location":"#revolutionizing-orchestration","title":"Revolutionizing Orchestration","text":"<p>Choreo is more than just an orchestration engine\u2014it\u2019s a comprehensive solution that transforms how teams interact with technology. By automating complex processes and enabling effective collaboration, Choreo helps you meet your objectives faster and more reliably than ever before. It stands as an indispensable tool for anyone looking to optimize their operations and systems, and harness the power of automation in a scalable, user-friendly environment.</p>"},{"location":"#join-us","title":"Join us","text":"<p>Have questions, ideas, bug reports or just want to chat? Come join discord server.</p>"},{"location":"01-installation/01_installation/","title":"Installation","text":""},{"location":"01-installation/01_installation/#cpu-architecture","title":"CPU architecture","text":"<p>All the choreo components run on both AMD and ARM based CPU</p>"},{"location":"01-installation/01_installation/#operating-system","title":"Operating system","text":"<p>We tested on WSL for windows and Linux and darwin OS.</p>"},{"location":"01-installation/01_installation/#choreoctl","title":"Choreoctl","text":"<p>Choreoctl is a command line tool for interacting with <code>Choreo</code>.</p> <p>choreoctl is a single binary built for linux and Mac OS, distributed via ghreleases. It</p> linux/Mac OSPackages <p>To download &amp; install the latest release the following automated installation script can be used.</p> <pre><code>bash -c \"$(curl -sL https://github.com/kform-dev/choreo/raw/main/install-choreoctl.sh)\"\n</code></pre> <p>As a result, the latest <code>choreoctl</code> version will be installed in the /usr/local/bin directory and the version information will be printed out.</p> <p>To install a specific version of <code>choreoctl</code>, provide the version with -v flag to the installation script:</p> <pre><code>bash -c \"$(curl -sL https://github.com/kform-dev/choreo/raw/main/install-choreoctl.sh)\" -- -v 0.0.1\n</code></pre> <p>Linux users running distributions with support for deb/rpm packages can install choreoctl using pre-built packages:</p> <pre><code>bash -c \"$(curl -sL https://github.com/kform-dev/choreo/raw/main/install-choreoctl.sh)\" -- --use-pkg\n</code></pre>"},{"location":"01-installation/01_installation/#choreoctl-autocomplete","title":"Choreoctl autocomplete","text":"bashzsh <pre><code>source &lt;(choreoctl completion bash) # set up autocomplete in bash into the current shell, bash-completion package should be installed first.\necho \"source &lt;(choreoctl completion bash)\" &gt;&gt; ~/.bashrc # add autocomplete permanently to your bash shell.\n</code></pre> <pre><code>source &lt;(choreoctl completion zsh)  # set up autocomplete in zsh into the current shell\necho '[[ $commands[choreoctl] ]] &amp;&amp; source &lt;(choreoctl completion zsh)' &gt;&gt; ~/.zshrc # add autocomplete permanently to your zsh shell\n</code></pre>"},{"location":"02-getting-started/01_getting_started/","title":"Getting Started","text":"<p>For users that have a github account github codespaces </p> Run within CodespacesRun local <p>Open code spaces </p> <p>go to the Hello World example and follow the README</p> <p>First check the prerequisites. </p> <p>clone the choreo-examples repo locally</p> <pre><code>git clone https://github.com/kform-dev/choreo-examples\n</code></pre> <p>go to the Hello World example and follow the README</p>"},{"location":"03-userguide/01_about/","title":"About","text":"<p><code>Choreo</code> is an innovative tool designed to bridge the gap between development and production environments through a unified technology framework. Equipped with both server-side and client-side components, <code>Choreo</code> facilitates seamless transitions from development to production, making it an indispensable tool for dynamic application environments.</p>"},{"location":"03-userguide/01_about/#dual-environment-functionality","title":"Dual-Environment Functionality","text":"<p><code>Choreo</code> excels in both development (<code>dev</code>) and production (<code>prod</code>) settings. In development, users can evolve and update a base reference, continually refining their use cases with new data or business logic. In production, <code>Choreo</code> operates using a predefined reference, executing established logic with high reliability and consistency.</p>"},{"location":"03-userguide/01_about/#key-components","title":"Key Components","text":""},{"location":"03-userguide/01_about/#project","title":"Project","text":"<p>A Choreo project is a collection of resources in the form of <code>.yaml</code> or <code>.yml</code> stored in a directory. <code>Choreo</code> uses 3 main sub-directories in a package called <code>crds</code>, <code>in</code> and <code>refs</code>. </p> <ul> <li>The <code>crd</code> directory stores all the external API(s)</li> <li>The <code>in</code> directory stores all the <code>business logic</code> aka <code>programs</code> and <code>input data</code> associated with a project. </li> <li>The <code>refs</code> directory stores all the references to child choreo packages that can include additional <code>crds</code>, <code>business logic</code> or <code>data</code></li> </ul>"},{"location":"03-userguide/01_about/#server","title":"Server","text":"<p>The <code>Choreo</code> server can be initiated in two primary modes:</p> <ul> <li><code>User Mode</code>: This mode is tailored for users who prefer hands-on control over their project environments. Users manually clone a project and direct the Choreo server to the project directory upon startup. This mode fully supports version control operations, allowing users to commit, stash, push, and manage their changes using e.g. standard git commands. It is ideal for developers who need to interact directly with their codebase and version history.</li> <li><code>Choreo Mode</code>: Designed for automated efficiency, this mode enables the server to autonomously manage project directories. It clones repositories based on an immutable reference, suiting both manual interventions and automated processes. While it simplifies repository operations, it still supports a subset of essential version control functions, making it suitable for scenarios where streamlined, consistent deployments and updates are crucial.</li> </ul>"},{"location":"03-userguide/01_about/#runner","title":"Runner","text":"<p><code>Choreo</code>\u2019s runner operates in two distinct modes, catering to different operational needs:</p> <ul> <li><code>Dev Mode</code>: Tailored for development tasks, this mode handles specific operations, executing them to completion and allowing for iterative testing and development. The dev mode is used to test new data input or changing reconciler logic.</li> <li><code>Prod Mode</code>: Designed for production, this mode enables the runner to continuously process and react to events with its built-in reconciler logic, ideal for monitoring and observing ongoing activities within the environment.</li> </ul>"},{"location":"03-userguide/01_about/#result-manager","title":"Result manager","text":"<p>Results from operations are meticulously captured in conditions and stored in snapshots at the end of each run, providing a persistent and immutable record of system states and data outputs. In continuous prod mode, the server must be stopped to finalize and store results, facilitating comprehensive comparisons through diffs between successive runs.</p> <p>More details will be explained in the respective sections of the user guide.</p>"},{"location":"03-userguide/02_project/","title":"Project","text":"<p>A <code>Choreo</code> project organizes resources within a directory structure designed to streamline the management and deployment of the automation logic. A typical <code>Choreo</code> package contains four main sub-directories: <code>crds</code>, <code>reconcilers</code>, <code>in</code>, and <code>refs</code> that define together your automation logic.</p> <p>Directory breakdown</p> <ul> <li>CRDs (<code>crds</code>): This directory houses all external APIs and any associated libraries, complete with getters and setters, defining the schemas for resource validation and manipulation.</li> <li>Reconcilers (<code>reconcilers</code>): Stores the business logic, or reconcilers, each within its own subdirectory. This includes both the configuration files and the executable logic responsible for your automation logic.</li> <li>Input Data (<code>in</code>): This directory contains all input data that drives business logic within the project.</li> <li>References (<code>refs</code>): Maintains links to child Choreo packages, which may include additional CRDs, business logic, or data, enabling modular project expansion and reuse.</li> </ul> <p><code>Choreo</code> operates within the context of a root package, typically the working directory from which the Choreo CLI is invoked. This root package may incorporate an entire configuration hierarchy, including child packages defined via upstream references.</p>"},{"location":"03-userguide/02_project/#apis-and-api-extensions","title":"APIs and API extensions","text":"<p><code>Choreo</code> supports cutomizing resources through Custom Resource Definitions (CRDs), allowing users to define custom schemas for their automation environment. Projects can incorporate CRDs directly within the crds directory or through external references to repositories. These CRDs establish the structural schemas for resources (APIs), enhancing the system\u2019s adaptability to specific resources for your automation.</p>"},{"location":"03-userguide/02_project/#reconcilers","title":"Reconcilers","text":"<p>Reconcilers are central to your automation functionality, defining the business logic applied to resources for your use case. Each reconciler specifies:</p> <ul> <li>A unique name.</li> <li>A conditionTyoe used to reflect the status of the business logic outcome in a condition.</li> <li>The resources it targets (for, own, watch resources)</li> <li>The business logic for the use case.</li> </ul> <p><code>Choreo</code> promotes a \u201clow-code/no-code\u201d philosophy, aiming to simplify the user experience and broaden accessibility. Supported languages for reconciler definitions include:</p> <ul> <li>Starlark (python)</li> <li>Jinja2 templates</li> <li>Go templates</li> </ul>"},{"location":"03-userguide/02_project/#upstreamrefs","title":"UpstreamRefs","text":"<p><code>Choreo</code> allows for reusable packages accross multiple project through the use of upstream refs. An upstream ref is basically a child <code>Choreo</code> instance of a root <code>Choreo</code> package. </p>"},{"location":"03-userguide/02_project/#data-input","title":"Data (Input)","text":"<p>Besides the built-in choreo apis, input data can also be provided in a choreo package. The input data, aligned with the API definitions, get invoked and will trigger the reconciler business logic defined in the <code>Choreo</code> instance.</p>"},{"location":"03-userguide/03_server/","title":"Choreo Server","text":"<p>The Choreo server can be started in two operational modes: <code>Static</code> Mode and <code>Dynamic</code> Mode. These distinct modes are designed to accommodate different workflows, allowing for both hands-on development and automated production operations.</p>"},{"location":"03-userguide/03_server/#static-mode","title":"Static Mode","text":""},{"location":"03-userguide/03_server/#overview","title":"Overview","text":"<p><code>Static</code> Mode gives developers full control over the project environment. This mode is ideal for development settings where direct interaction with the repository and version control systems is necessary.</p>"},{"location":"03-userguide/03_server/#operations","title":"Operations","text":"<p>In Static Mode, users are responsible for cloning the Choreo project repository and can choose their preferred technology for this task. Once started in this mode, the server\u2019s project context remains fixed and cannot be changed dynamically.</p> <p>To start the server in User Mode, specify the directory path:</p> <pre><code>choreo server start [DIRECTORY] [flags]\n</code></pre> <p>This mode allows full access to version control commands such as commit, stash, and push, facilitating an interactive development process.</p>"},{"location":"03-userguide/03_server/#dynamic-mode","title":"Dynamic Mode","text":""},{"location":"03-userguide/03_server/#overview_1","title":"Overview","text":"<p>Dynamic Mode abstracts the management of the Choreo repository/package, handling the cloning and setup processes automatically. This mode is versatile, supporting both development and production environments where choreo managing the version control of the Choreo package.</p>"},{"location":"03-userguide/03_server/#operations_1","title":"Operations","text":"<p>The below command shows how start the server in Dynamic Mode:</p> <pre><code>choreo server start [flags]\n</code></pre> <p>To dynamically configure the choreo package use the apply command with the necessary repository details:</p> <pre><code>choreo server apply [URL] [DIR] [REF] [BRANCH] [flags]\n</code></pre>"},{"location":"03-userguide/03_server/#mode-differentiation","title":"Mode Differentiation","text":"<ul> <li>Development Environment: Specify a branch to operate in development mode, allowing manual or automated system instructions for operations, commits, updates, and diffs.</li> <li>Production Environment: Omitting the branch defaults the server to production mode, typically utilizing the main branch for continuous operation.</li> </ul>"},{"location":"03-userguide/03_server/#dynamic-context-switching","title":"Dynamic Context Switching","text":"<p>Dynamic context switching is possible using the following command, which is useful for rolling back to a stable reference or advancing to a new validated reference:</p> <pre><code>choreo server apply [URL] [DIR] [REF] [BRANCH] [flags]\n</code></pre> <p>This feature is particularly valuable in production for quick rollbacks or in development for committing changes to a new feature branch.</p>"},{"location":"03-userguide/03_server/#status-retrieval","title":"Status Retrieval","text":"<p>To check the current status or configuration of the server, use the get command:</p> <pre><code>choreo server get\n</code></pre> <p>This command is crucial for monitoring the server\u2019s state and ensuring that all operations are transparent and under control.</p>"},{"location":"03-userguide/03_server/#server-flags","title":"Server flags","text":"<ul> <li>r (internal reconcilers): embed internal reconcilers, such as IPAM, VLAN, AS, GENID based resource handlers for claiming and registrating resource identifiers</li> <li>s (yang schema validation and config generation): use yang schema validation and config generation</li> </ul>"},{"location":"03-userguide/04_runner/","title":"Runner","text":"<p>The Choreo runner operates as the execution engine of the system, capable of running in two distinct modes: Development Mode and Production Mode. These modes are tailored to support different stages of project development and deployment.</p>"},{"location":"03-userguide/04_runner/#resources","title":"Resources","text":"<p>Choreo is fundamentally an API-first system, utilizing Kubernetes Resource Model (KRM) Custom Resource Definitions (CRDs) as APIs to manage and interact with resources. When the runner is initiated, it loads CRDs and input data from associated directories in the Choreo server. Following data initialization, reconcilers are instantiated to execute their business logic based on the updated resources in the system. This setup leverages a list and watch mechanism, allowing reconcilers to trigger and operate based on data.</p>"},{"location":"03-userguide/04_runner/#developer-mode","title":"Developer mode","text":""},{"location":"03-userguide/04_runner/#purpose","title":"Purpose","text":"<p>Development mode is designed for testing and validation, ideal for developers looking to verify new data inputs, API functionalities, or business logic changes. This mode provides an iterative environment where changes can be applied, tested, and observed in a controlled setting.</p>"},{"location":"03-userguide/04_runner/#operation","title":"Operation","text":"<p>In Development Mode, the runner operates on a single-run basis, executing the following steps:</p> <ol> <li>Initialization: Loads CRDs, librariers, reconciler logic and input data into the system. Potentially leveraging child choreo projects using upstream references.</li> <li>Execution: Starts the reconcilers which consume the data and execute the business logic based on resource changes using its event driven framework.</li> <li>Observation: An observer component monitors the execution process, assessing outcomes based on various indicators such as error messages, condition statuses, and event triggers.</li> <li>Optionally when the -s flag was initiated a config validation and schema validation will be executed.</li> </ol>"},{"location":"03-userguide/04_runner/#completion","title":"Completion","text":"<p>The process concludes when the observer determines the success or failure of the run. The results are then presented to the developer, facilitating quick feedback and iteration.</p> <pre><code>choreoctl run once\n</code></pre> <pre><code>loading ...\nloading done\nrunning reconcilers ...\nrunning root reconciler hello-world\nRun root summary\nexecution success, time(msec) 12.487ms\nReconciler                          Start Stop Requeue Error\nhelloworlds.example.com.hello-world 2     2    0       0    completed\n</code></pre>"},{"location":"03-userguide/04_runner/#production-mode","title":"Production mode","text":""},{"location":"03-userguide/04_runner/#purpose_1","title":"Purpose","text":"<p>Production mode is designed for continuous operation, when you decided the input data and business logic is suitable for produciton.</p>"},{"location":"03-userguide/04_runner/#operation_1","title":"Operation","text":"<p>In Production Mode, the runner continuously processes and reacts to changes in the environment, driven by event triggers and updates to the resources:</p> <ol> <li>Start: Initializes and begins continuous processing.</li> <li>Running: Maintains ongoing observation and response to resource changes and system events.</li> <li>Management: Allows for stopping and starting of operations to manage updates or maintenance tasks effectively.</li> </ol> <p>start the server in continuous mode</p> <pre><code>choreoctl run start\n</code></pre> <p>stop the server</p> <pre><code>choreoctl run stop\n</code></pre>"},{"location":"03-userguide/05_results/","title":"Results","text":"<p>In Choreo, results management is intricately designed to cater to both development and production environments, leveraging logs and API interactions to monitor and understand the status and output of operations.</p>"},{"location":"03-userguide/05_results/#developer-mode","title":"Developer mode","text":"<p>The development environment is enhanced with additional tools to aid in testing and troubleshooting:</p> <ul> <li>Observer Insights: The observer component plays a critical role in development mode by informing users about the success or failure of each run. This immediate feedback is crucial for iterative development and troubleshooting.</li> <li>Snapshot Storage: Upon a successful run, a snapshot of the data produced during that operation is stored. This allows developers to capture and review the state of the system at the time of execution, which is invaluable for debugging and historical analysis.</li> </ul>"},{"location":"03-userguide/05_results/#managing-results-with-choreo-commands","title":"Managing Results with Choreo Commands","text":""},{"location":"03-userguide/05_results/#running-and-observing-operations","title":"Running and Observing Operations","text":"<p>To initiate a run and observe the results in development mode, use the following command:</p> <pre><code>choreoctl run once\n</code></pre> <p>This command executes the operational logic once and provides an output summarizing the execution:</p> <pre><code>loading ...\nopened repo https://github.com/kuidio/kuid.git ref cb752b9df3fe1ca9285a40e10d44dc87cd021162 ....\nopened repo https://github.com/kubenet-dev/apis.git ref 71e5d139d272026db682be8a815d33a9f10d7b1f ....\nopened repo https://github.com/sdcio/config-server.git ref aaf183a28ba8a3cff222321a767fc0022923af19 ....\nloading done\nrunning reconcilers ...\nrunning root reconciler config\nRun root summary\nexecution success, time(msec) 11.471ms\nReconciler                                                 Start Stop Requeue Error\ndevice.network.kubenet.dev.interfaces.srlinux.nokia.com    4     4    0       0    device.network.kubenet.dev.subinterfaces.srlinux.nokia.com 2     2    0       0    nodes.infra.kuid.dev.id                                    2     2    0       0    nodes.infra.kuid.dev.itfce                                 2     2    0       0    running config validator ...\ncompleted\n</code></pre>"},{"location":"03-userguide/05_results/#analyzing-changes-with-snapshots","title":"Analyzing Changes with Snapshots","text":"<p>Developers can compare current results with previous snapshots to understand the impact of changes:</p> <pre><code>choreoctl run diff\n</code></pre> <p>This command outputs a detailed list of changes between the current and previous runs, helping identify new or altered resources:</p> <pre><code>= config.sdcio.dev/v1alpha1, Kind=Config interface.kubenet.region1.us-east.node1.0.0.irb\n= config.sdcio.dev/v1alpha1, Kind=Config interface.kubenet.region1.us-east.node1.0.0.system\n~ config.sdcio.dev/v1alpha1, Kind=Config kubenet.region1.us-east.node1\n= config.sdcio.dev/v1alpha1, Kind=Config subinterface.kubenet.region1.us-east.node1.0.0.0.system\n= config.sdcio.dev/v1alpha1, Kind=RunningConfig kubenet.region1.us-east.node1\n~ config.sdcio.dev/v1alpha1, Kind=RunningConfig kubenet.region1.us-east.node1.tree\n= device.network.kubenet.dev/v1alpha1, Kind=Interface kubenet.region1.us-east.node1.0.0.irb\n= device.network.kubenet.dev/v1alpha1, Kind=Interface kubenet.region1.us-east.node1.0.0.system\n= device.network.kubenet.dev/v1alpha1, Kind=SubInterface kubenet.region1.us-east.node1.0.0.0.system\n= infra.kuid.dev/v1alpha1, Kind=Node kubenet.region1.us-east.node1\n= ipam.be.kuid.dev/v1alpha1, Kind=IPClaim kubenet.default.10.0.0.0-24\n= ipam.be.kuid.dev/v1alpha1, Kind=IPClaim kubenet.default.1000---32\n= ipam.be.kuid.dev/v1alpha1, Kind=IPClaim kubenet.region1.us-east.node1.ipv4\n= ipam.be.kuid.dev/v1alpha1, Kind=IPEntry default.kubenet.default.10.0.0.0-24\n= ipam.be.kuid.dev/v1alpha1, Kind=IPEntry default.kubenet.default.10.0.0.0-32\n= ipam.be.kuid.dev/v1alpha1, Kind=IPEntry default.kubenet.default.1000---32\n= ipam.be.kuid.dev/v1alpha1, Kind=IPIndex kubenet.default\n...\n</code></pre> <p>Snapshot Options</p> <p>Choreo also provides options to enhance the detail level in snapshot comparisons:</p> <ul> <li>-i option: Includes internal Choreo API states in the diff.</li> <li>-a option: Displays detailed attributes of each element.</li> <li>-m option: Shows managed fields details, providing deeper insights into what has changed and why.</li> </ul> <p>example with -a option</p> <pre><code>choreoctl run diff -a\n</code></pre> <p>output</p> <pre><code>+= config.sdcio.dev/v1alpha1, Kind=Config interface.kubenet.region1.us-east.node1.0.0.irb\n= config.sdcio.dev/v1alpha1, Kind=Config interface.kubenet.region1.us-east.node1.0.0.system\n~ config.sdcio.dev/v1alpha1, Kind=Config kubenet.region1.us-east.node1\n  bytes.Join({\n\"apiVersion: config.sdcio.dev/v1alpha1\\nkind: Config\\nmetadata:\\n  c\",\n        \"reationTimestamp: \\\"2024-11-12T11:01:37Z\\\"\\n  generation: \",\n-       \"6\",\n+       \"7\",\n        \"\\n  labels:\\n    config.sdcio.dev/targetName: kubenet.region1.us-e\",\n        \"ast.node1\\n    config.sdcio.dev/targetNamespace: default\\n  name: \",\n        ... // 124 identical bytes\n        \": true\\n    kind: Node\\n    name: kubenet.region1.us-east.node1\\n  \",\n        \"  uid: 1ecb56f1-4331-4a2e-98f7-92a2aef04cfd\\n  resourceVersion: \\\"\",\n-       \"6\",\n+       \"7\",\n        \"\\\"\\n  uid: b9144c27-09cb-4790-9d8c-31896ce8e09a\\nspec:\\n  config:\\n  \",\n        \"- path: /\\n    value:\\n      interface:\\n      - admin-state: enabl\",\n        \"e\\n        description: k8s-\",\n-       \"irb\\n        name: irb0\\n      - admin-state: enable\\n        descr\",\n-       \"iption: k8s-system\\n        name: system0\\n        subinterface:\\n \",\n-       \"       - admin-state: enable\\n          description: k8s-system.0\",\n-       \"\\n          index: 0\\n          ipv4:\\n            address:\\n       \",\n-       \"     - ip-prefix: 10.0.0.0/32\\n           \",\n+       \"system\\n        name: system0\\n        subinterface:\\n        - adm\",\n+       \"in-state: enable\\n          description: k8s-system.0\\n          i\",\n+       \"ndex: 0\\n          ipv4:\\n            address:\\n            - ip-pr\",\n+       \"efix: 10.0.0.0/32\\n            admin-state: enable\\n            un\",\n+       \"numbered:\\n              admin-state: disable\\n      -\",\n        \" admin-state: enable\\n        \",\n-       \"    unnumbered:\\n              admin-state: disable\",\n+       \"description: k8s-irb\\n        name: irb0\",\n        \"\\n      network-instance:\\n      - admin-state: enable\\n        des\",\n        \"cription: Management network instance\\n        name: mgmt\\n       \",\n        ... // 10384 identical bytes\n  }, \"\")\n= config.sdcio.dev/v1alpha1, Kind=Config subinterface.kubenet.region1.us-east.node1.0.0.0.system\n= config.sdcio.dev/v1alpha1, Kind=RunningConfig kubenet.region1.us-east.node1\n~ config.sdcio.dev/v1alpha1, Kind=RunningConfig kubenet.region1.us-east.node1.tree\n  bytes.Join({\n... // 249 identical bytes\n        \": true\\n    kind: Node\\n    name: kubenet.region1.us-east.node1\\n  \",\n        \"  uid: 1ecb56f1-4331-4a2e-98f7-92a2aef04cfd\\n  resourceVersion: \\\"\",\n-       \"2\",\n+       \"3\",\n        \"\\\"\\n  uid: 29cbcf9d-127e-4750-8cba-069560cf82d0\\nspec: {}\\nstatus:\\n \",\n        \" value:\\n    network-instance:\\n    - admin-state: enable\\n      de\",\n        ... // 4581 identical bytes\n        \"      server-list:\\n        - 10.210.21.227\\n        - 10.210.21.2\",\n        \"28\\n      grpc-server:\\n      - admin-state: enable\\n        name: \",\n+       \"insecure-\",\n        \"mgmt\\n        network-instance: mgmt\\n        \",\n-       \"rate-limit: 65000\\n        services:\\n        - gnmi\\n        - gno\",\n-       \"i\\n        - gribi\\n        - p4rt\\n        tls-profile: clab-profi\",\n-       \"le\\n        trace-options:\\n        - request\\n        - response\\n \",\n-       \"       - common\\n        unix-socket:\\n          admin-state: enab\",\n-       \"le\\n      - admin-state: enable\\n        name: insecure-mgmt\\n     \",\n-       \"   network-instance: mgmt\\n        port: 57401\\n        rate-limit\",\n-       \": 65000\\n        services:\\n        - gnmi\\n        - gnoi\\n        \",\n-       \"- gribi\\n        - p4rt\",\n+       \"port: 57401\\n        rate-limit: 65000\\n        services:\\n        \",\n+       \"- gnmi\\n        - gnoi\\n        - gribi\\n        - p4rt\\n        tra\",\n+       \"ce-options:\\n        - request\\n        - response\\n        - commo\",\n+       \"n\\n        unix-socket:\\n          admin-state: enable\\n      - adm\",\n+       \"in-state: enable\\n        name: mgmt\\n        network-instance: mg\",\n+       \"mt\\n        rate-limit: 65000\\n        services:\\n        - gnmi\\n  \",\n+       \"      - gnoi\\n        - gribi\\n        - p4rt\\n        tls-profile:\",\n+       \" clab-profile\",\n        \"\\n        trace-options:\\n        - request\\n        - response\\n   \",\n        \"     - common\\n        unix-socket:\\n          admin-state: enable\",\n        ... // 4782 identical bytes\n  }, \"\")\n= device.network.kubenet.dev/v1alpha1, Kind=Interface kubenet.region1.us-east.node1.0.0.irb\n= device.network.kubenet.dev/v1alpha1, Kind=Interface kubenet.region1.us-east.node1.0.0.system\n= device.network.kubenet.dev/v1alpha1, Kind=SubInterface kubenet.region1.us-east.node1.0.0.0.system\n= infra.kuid.dev/v1alpha1, Kind=Node kubenet.region1.us-east.node1\n= ipam.be.kuid.dev/v1alpha1, Kind=IPClaim kubenet.default.10.0.0.0-24\n= ipam.be.kuid.dev/v1alpha1, Kind=IPClaim kubenet.default.1000---32\n= ipam.be.kuid.dev/v1alpha1, Kind=IPClaim kubenet.region1.us-east.node1.ipv4\n= ipam.be.kuid.dev/v1alpha1, Kind=IPEntry default.kubenet.default.10.0.0.0-24\n= ipam.be.kuid.dev/v1alpha1, Kind=IPEntry default.kubenet.default.10.0.0.0-32\n= ipam.be.kuid.dev/v1alpha1, Kind=IPEntry default.kubenet.default.1000---32\n= ipam.be.kuid.dev/v1alpha1, Kind=IPIndex kubenet.default\n</code></pre>"},{"location":"03-userguide/05_results/#viewing-dependencies","title":"Viewing Dependencies","text":"<p>Understanding dependencies between resources is critical for managing complex systems. Choreo facilitates this with visualization commands that delineate how resources are interconnected:</p> <pre><code>choreoctl run deps\n</code></pre> <p>This functionality not only aids in troubleshooting but also helps in planning and verifying automation integrity.</p> <pre><code>...\nIPIndex.ipam.be.kuid.dev/v1alpha1 kubenet.default\n+-IPClaim.ipam.be.kuid.dev/v1alpha1 kubenet.default.10.0.0.0-24\n  +-IPEntry.ipam.be.kuid.dev/v1alpha1 default.kubenet.default.10.0.0.0-24\n+-IPClaim.ipam.be.kuid.dev/v1alpha1 kubenet.default.1000---32\n  +-IPEntry.ipam.be.kuid.dev/v1alpha1 default.kubenet.default.1000---32\nNode.infra.kuid.dev/v1alpha1 kubenet.region1.us-east.node1\n+-Config.config.sdcio.dev/v1alpha1 kubenet.region1.us-east.node1\n+-Interface.device.network.kubenet.dev/v1alpha1 kubenet.region1.us-east.node1.0.0.irb\n  +-Config.config.sdcio.dev/v1alpha1 interface.kubenet.region1.us-east.node1.0.0.irb\n+-Interface.device.network.kubenet.dev/v1alpha1 kubenet.region1.us-east.node1.0.0.system\n  +-Config.config.sdcio.dev/v1alpha1 interface.kubenet.region1.us-east.node1.0.0.system\n+-IPClaim.ipam.be.kuid.dev/v1alpha1 kubenet.region1.us-east.node1.ipv4\n  +-IPEntry.ipam.be.kuid.dev/v1alpha1 default.kubenet.default.10.0.0.0-32\n+-RunningConfig.config.sdcio.dev/v1alpha1 kubenet.region1.us-east.node1\n+-RunningConfig.config.sdcio.dev/v1alpha1 kubenet.region1.us-east.node1.tree\n+-SubInterface.device.network.kubenet.dev/v1alpha1 kubenet.region1.us-east.node1.0.0.0.system\n  +-Config.config.sdcio.dev/v1alpha1 subinterface.kubenet.region1.us-east.node1.0.0.0.system\n...\n</code></pre>"},{"location":"03-userguide/05_results/#viewing-result","title":"Viewing Result","text":"<p>Understanding the details of the result execution is possible with the following command</p> <ul> <li>-o option: allows to customize the output format using the following options</li> <li>reconciler: provides a summary per reconciler (default output format)</li> <li>resource: provides a summary per resource</li> <li>raw: provides a view on the sequence of the reconciler execution</li> </ul> <pre><code>choreoctl run result -o raw\n</code></pre> <p>example output</p> <pre><code>Run root summary\nexecution success, time(msec) 11.471ms\nEventTime                      Reconciler                                                 Resource                                                                                   Operation Message\n2024-11-13 00:59:50.240876 UTC nodes.infra.kuid.dev.id                                    infra.kuid.dev.Node.default.kubenet.region1.us-east.node1                                  START            2024-11-13 00:59:50.240899 UTC nodes.infra.kuid.dev.itfce                                 infra.kuid.dev.Node.default.kubenet.region1.us-east.node1                                  START            2024-11-13 00:59:50.240980 UTC device.network.kubenet.dev.subinterfaces.srlinux.nokia.com device.network.kubenet.dev.SubInterface.default.kubenet.region1.us-east.node1.0.0.0.system START            2024-11-13 00:59:50.241316 UTC device.network.kubenet.dev.interfaces.srlinux.nokia.com    device.network.kubenet.dev.Interface.default.kubenet.region1.us-east.node1.0.0.system      START            2024-11-13 00:59:50.241344 UTC device.network.kubenet.dev.interfaces.srlinux.nokia.com    device.network.kubenet.dev.Interface.default.kubenet.region1.us-east.node1.0.0.irb         START            2024-11-13 00:59:50.244228 UTC device.network.kubenet.dev.subinterfaces.srlinux.nokia.com device.network.kubenet.dev.SubInterface.default.kubenet.region1.us-east.node1.0.0.0.system STOP             2024-11-13 00:59:50.244235 UTC device.network.kubenet.dev.subinterfaces.srlinux.nokia.com device.network.kubenet.dev.SubInterface.default.kubenet.region1.us-east.node1.0.0.0.system START            2024-11-13 00:59:50.244307 UTC device.network.kubenet.dev.interfaces.srlinux.nokia.com    device.network.kubenet.dev.Interface.default.kubenet.region1.us-east.node1.0.0.irb         STOP             2024-11-13 00:59:50.244315 UTC device.network.kubenet.dev.interfaces.srlinux.nokia.com    device.network.kubenet.dev.Interface.default.kubenet.region1.us-east.node1.0.0.irb         START            2024-11-13 00:59:50.244348 UTC device.network.kubenet.dev.interfaces.srlinux.nokia.com    device.network.kubenet.dev.Interface.default.kubenet.region1.us-east.node1.0.0.system      STOP             2024-11-13 00:59:50.244353 UTC device.network.kubenet.dev.interfaces.srlinux.nokia.com    device.network.kubenet.dev.Interface.default.kubenet.region1.us-east.node1.0.0.system      START            2024-11-13 00:59:50.245140 UTC nodes.infra.kuid.dev.id                                    infra.kuid.dev.Node.default.kubenet.region1.us-east.node1                                  STOP             2024-11-13 00:59:50.245145 UTC nodes.infra.kuid.dev.id                                    infra.kuid.dev.Node.default.kubenet.region1.us-east.node1                                  START            2024-11-13 00:59:50.246552 UTC nodes.infra.kuid.dev.itfce                                 infra.kuid.dev.Node.default.kubenet.region1.us-east.node1                                  STOP             2024-11-13 00:59:50.246557 UTC nodes.infra.kuid.dev.itfce                                 infra.kuid.dev.Node.default.kubenet.region1.us-east.node1                                  START            2024-11-13 00:59:50.247734 UTC device.network.kubenet.dev.interfaces.srlinux.nokia.com    device.network.kubenet.dev.Interface.default.kubenet.region1.us-east.node1.0.0.irb         STOP             2024-11-13 00:59:50.247792 UTC device.network.kubenet.dev.interfaces.srlinux.nokia.com    device.network.kubenet.dev.Interface.default.kubenet.region1.us-east.node1.0.0.system      STOP             2024-11-13 00:59:50.248088 UTC device.network.kubenet.dev.subinterfaces.srlinux.nokia.com device.network.kubenet.dev.SubInterface.default.kubenet.region1.us-east.node1.0.0.0.system STOP             2024-11-13 00:59:50.250149 UTC nodes.infra.kuid.dev.id                                    infra.kuid.dev.Node.default.kubenet.region1.us-east.node1                                  STOP             2024-11-13 00:59:50.252347 UTC nodes.infra.kuid.dev.itfce                                 infra.kuid.dev.Node.default.kubenet.region1.us-east.node1                                  STOP   </code></pre>"},{"location":"03-userguide/05_results/#production-mode","title":"Production mode","text":"<p>In a production setting, users/machines can consult logs or interact directly with the API server to check the status of resources. This provides a real-time insight into the system\u2019s operational status, helping identify any issues or confirm the health of the processes.</p>"},{"location":"03-userguide/06_datachanges/","title":"Managing Data Changes","text":"<p>In Choreo, you can update the system\u2019s input using the choreoctl apply command. This command allows you to apply configuration changes directly from a YAML file, facilitating the dynamic modification of resources.</p>"},{"location":"03-userguide/06_datachanges/#applying-changes","title":"Applying Changes","text":"<p>To change the input data, you can use the following command, which feeds the YAML data directly into choreoctl:</p> <pre><code>choreoctl apply -f - &lt;&lt;EOF\napiVersion: topo.kubenet.dev/v1alpha1\nkind: Topology\nmetadata:\nname: kubenet\nnamespace: default\nspec:\ndefaults:\nprovider: srlinux.nokia.com\nplatformType: ixrd3\nversion: 24.7.2\nregion: region1\nsite: us-east\nnodes:\n- name: node1\n- name: node2\n- name: node3\n- name: node4\nlinks:\n- endpoints:\n- {node: node1, port: 1, endpoint: 1, adaptor: \"sfp\"}\n- {node: node2, port: 1, endpoint: 1, adaptor: \"sfp\"}\n- endpoints:\n- {node: node2, port: 2, endpoint: 1, adaptor: \"sfp\"}\n- {node: node3, port: 2, endpoint: 1, adaptor: \"sfp\"}\n- endpoints:\n- {node: node3, port: 1, endpoint: 1, adaptor: \"sfp\"}\n- {node: node4, port: 1, endpoint: 1, adaptor: \"sfp\"}\n- endpoints:\n- {node: node4, port: 2, endpoint: 1, adaptor: \"sfp\"}\n- {node: node1, port: 2, endpoint: 1, adaptor: \"sfp\"}\nEOF\n</code></pre>"},{"location":"03-userguide/06_datachanges/#developer-mode","title":"Developer Mode:","text":"<p>In Developer Mode, you must execute the <code>choreoctl run once</code> to apply the data. Th apply command does not immediately apply changes to the live API but adds or modifies files in the input directory after validating the data against the schema.</p> <p>You can also manually edit, add, or delete files in the input directory to manage your configurations. This flexibility allows developers to experiment and test changes locally before they are pushed to production.</p>"},{"location":"03-userguide/06_datachanges/#production-mode","title":"Production Mode:","text":"<p>In Production Mode, changes applied via choreoctl are immediately validated and integrated into the live system environment, ensuring that updates are propagated in real-time. </p>"},{"location":"04-devguide/01_about/","title":"Developer guide","text":"<p>The developper guide is designed to help developers extend Choreo with custom APIs and custom business logic (reconcilers) for their use cases.</p>"},{"location":"04-devguide/01_about/#apis","title":"APIs","text":"<p>At the heart of <code>Choreo</code> are its APIs, which are implemented using Custom Resource Definitions (CRDs). These CRDs extend Choreo\u2019s native capabilities, allowing developers to define custom resources specific to their needs. Each API in Choreo is designed to be self-descriptive and aligned with standard KRM practices, ensuring ease of use and integration.</p>"},{"location":"04-devguide/01_about/#reconcilers","title":"Reconcilers","text":"<p>Reconcilers are another pivotal component of <code>Choreo</code>. They attach to a resource in Choreo and react to resource changes triggering necessary updates and adjustments based on their business logic. Choreo support the following reconciler types right now.</p> <ul> <li>python/starlark</li> <li>go template</li> <li>jinja2 template</li> </ul>"},{"location":"04-devguide/apis/01_crd/","title":"API(s)","text":"<p>Choreo adopts an API-first approach, fundamentally leveraging the Kubernetes Resource Model (KRM) as defined by Kubernetes. In this system, each API object represents a resource that Choreo imports using Custom Resource Definitions (CRDs). CRDs allow for the extension of Choreo's capabilities by defining new resource types with associated schemas.</p>"},{"location":"04-devguide/apis/01_crd/#defining-a-crd","title":"Defining a CRD","text":"<p>You can create a CRD in various ways:</p> <ul> <li>manually</li> <li>kubebuilder</li> <li>others: TBD </li> </ul> <p>Each CRD includes several critical pieces of metadata that define how the resource interacts with the API Server:</p> <ul> <li>Group: The API group to which the CRD belongs, helping to categorize and control API extensions.</li> <li>Kind: The type of the resource, which is typically a descriptive name in CamelCase.</li> <li>Version: Indicates the version of the API which can evolve over time.</li> <li>Scope: Determines whether the resource is Namespaced (available within specific namespaces) or Cluster-scoped (available across all namespaces).</li> <li>Names: Includes the plural, singular, and optionally short names used in API requests and user interfaces.</li> </ul>"},{"location":"04-devguide/apis/01_crd/#crd-example","title":"CRD example","text":"<p>Here is an example of a CRD definition for a custom resource named \u201cCronTab\u201d:</p> <pre><code>apiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n# name must match the spec fields below, and be in the form: &lt;plural&gt;.&lt;group&gt;\nname: crontabs.stable.example.com\nspec:\n# group name to use for REST API: /apis/&lt;group&gt;/&lt;version&gt;\ngroup: stable.example.com\n# list of versions supported by this CustomResourceDefinition\nversions:\n- name: v1\n# Each version can be enabled/disabled by Served flag.\nserved: true\n# One and only one version must be marked as the storage version.\nstorage: true\nschema:\nopenAPIV3Schema:\ntype: object\nproperties:\nspec:\ntype: object\nproperties:\ncronSpec:\ntype: string\nimage:\ntype: string\nreplicas:\ntype: integer\n# either Namespaced or Cluster\nscope: Namespaced\nnames:\n# plural name to be used in the URL: /apis/&lt;group&gt;/&lt;version&gt;/&lt;plural&gt;\nplural: crontabs\n# singular name to be used as an alias on the CLI and for display\nsingular: crontab\n# kind is normally the CamelCased singular type. Your resource manifests use this.\nkind: CronTab\n# shortNames allow shorter string to match your resource on the CLI\nshortNames:\n- ct\n</code></pre> <p>Key Components of a CRD:</p> <ul> <li>API Version and Kind: Identifies the CRD in the context of the Kubernetes API.</li> <li>Metadata Name: Specifies the name of the CRD in a format .. <li>Spec: Defines the group, versions, and scope of the CRD, including the schema used to validate each version.</li> <li>OpenAPI Schema     Embedded within the CRD is an openAPIV3Schema which specifies the structure and validation rules of the resource. This schema ensures that all instances of the resource conform to the defined specifications, such as required fields, field types, and additional metadata.</li>"},{"location":"04-devguide/apis/01_crd/#crd-usage-in-choreo","title":"CRD Usage in Choreo","text":"<p>In Choreo a CRD is stored in the crd folder of a project and will be imported when the choreo server starts. Once loaded CRUD operations can be performed on these resources.</p>"},{"location":"04-devguide/apis/02_kubebuilder/","title":"Generating crds using kubebuilder","text":"<p>Kubebuilder is a suite that simplifies building Kubernetes APIs using custom resource definitions (CRDs). It leverages Go structs along with controller-runtime annotations to automate and enhance the development process.</p>"},{"location":"04-devguide/apis/02_kubebuilder/#prerequisites","title":"Prerequisites","text":"<p>Before starting, ensure that Go is installed on your system. You can install Go by following the instructions here: Install go</p>"},{"location":"04-devguide/apis/02_kubebuilder/#setting-up-your-project","title":"Setting Up Your Project","text":"<p>This section demonstrates setting up a basic project structure manually. Typically, this is scaffolded.</p>"},{"location":"04-devguide/apis/02_kubebuilder/#initialize-the-project","title":"Initialize the Project","text":"<p>Create and navigate into a new project directory:</p> <pre><code>mkdir &lt;project-name&gt;; cd &lt;project-name&gt;\ngit init -b main\nmkdir -p apis/\n</code></pre> <p>initialize the go project</p> <p>update the go mod file using your project information</p> <pre><code>go mod init github.com/dummy/test\n</code></pre>"},{"location":"04-devguide/apis/02_kubebuilder/#prepare-the-makefile","title":"Prepare the Makefile","text":"<pre><code>cat &lt;&lt;\"EOF\" &gt; Makefile\n## Location to install dependencies to\nLOCALBIN ?= $(shell pwd)/bin\n$(LOCALBIN):\n    mkdir -p $(LOCALBIN)\n## Tool Binaries\nCONTROLLER_GEN ?= $(LOCALBIN)/controller-gen\nCONTROLLER_TOOLS_VERSION ?= v0.15.0\n\n# Setting SHELL to bash allows bash commands to be executed by recipes.\n# Options are set to exit when a recipe line exits non-zero or a piped command fails.\nSHELL = /usr/bin/env bash -o pipefail\n.SHELLFLAGS = -ec\n\n.PHONY: manifests\n\nall: manifests\n\n.PHONY: manifests\nmanifests: controller-gen ## Generate WebhookConfiguration, ClusterRole and CustomResourceDefinition objects.\nmkdir -p artifacts\n    $(CONTROLLER_GEN) rbac:roleName=manager-role crd paths=\"./apis/...\" output:crd:artifacts:config=crds\n\n.PHONY: controller-gen\ncontroller-gen: $(CONTROLLER_GEN) ## Download controller-gen locally if necessary.\n$(CONTROLLER_GEN): $(LOCALBIN)\ntest -s $(LOCALBIN)/controller-gen || GOBIN=$(LOCALBIN) go install sigs.k8s.io/controller-tools/cmd/controller-gen@$(CONTROLLER_TOOLS_VERSION)\nEOF\n</code></pre>"},{"location":"04-devguide/apis/02_kubebuilder/#generate-manifests","title":"Generate Manifests","text":"<pre><code>make manifests\n</code></pre>"},{"location":"04-devguide/apis/02_kubebuilder/#creating-your-first-api","title":"Creating Your First API","text":"<p>create a directory where we store your api artifacts</p> <pre><code>mkdir -p apis/foo/v1alpha1\n</code></pre> <p>create a doc.go file and the test_types.go file containing the api</p> <pre><code>cat &lt;&lt;\"EOF\" &gt; apis/foo/v1alpha1/doc.go\n// +kubebuilder:object:generate=true\n// +groupName=foo.example.com\n// Package v1alpha1 is the v1alpha1 version of the API.\npackage v1alpha1\nEOF\n</code></pre> <pre><code>cat &lt;&lt;\"EOF\" &gt; apis/foo/v1alpha1/test_types.go\npackage v1alpha1\n\nimport (\nmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n// TestSpec defines the desired state of the Test resource\ntype TestSpec struct {\n}\n// TestStatus defines the observed state of the Test resource\ntype TestStatus struct {\n}\n// +kubebuilder:object:root=true\n// +kubebuilder:subresource:status\n// Test is the Schema for the Test API\ntype Test struct {\nmetav1.TypeMeta   `json:\",inline\"`\nmetav1.ObjectMeta `json:\"metadata,omitempty\"`\nSpec   TestSpec   `json:\"spec,omitempty\"`\nStatus TestStatus `json:\"status,omitempty\"`\n}\n// TestList contains a list of Tests\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\ntype TestList struct {\nmetav1.TypeMeta `json:\",inline\" yaml:\",inline\"`\nmetav1.ListMeta `json:\"metadata,omitempty\"`\nItems           []Test `json:\"items\"`\n}\nEOF\n</code></pre> <p>run go mod tidy to resolve the dependencies</p> <pre><code>go mod tidy\n</code></pre> <p>generate your api</p> <pre><code>make manifests\n</code></pre> <p>start the server</p> <pre><code>choreoctl server start .\n</code></pre> <pre><code>choreoctl apply &lt;&lt;EOF\napiVersion: foo.example.com/v1alpha1\nkind: Test\nmetadata:\n  name: my-first-test\nEOF\n</code></pre>"},{"location":"04-devguide/apis/02_kubebuilder/#adding-parameters-with-validation","title":"Adding parameters with validation","text":"<p>crd generation</p> <p>crd validation</p> <pre><code>type TestSpec struct {\n// +kubebuilder:validation:MaxLength=15\n// +kubebuilder:validation:MinLength=3\n// FieldA defines the name of field A\nFieldA string `json:\"fieldA,omitempty\"`\n}\n</code></pre> <p>create an object with an empty fieldA in spec -&gt; acceppted</p> <pre><code>choreoctl apply &lt;&lt;EOF\napiVersion: foo.example.com/v1alpha1\nkind: Test\nmetadata:\nname: my-first-test\nspec:\nEOF\n</code></pre> <p>create an object with a fieldA but with 1 char in spec -&gt; rejected</p> <pre><code>choreoctl apply - &lt;&lt;EOF\napiVersion: foo.example.com/v1alpha1\nkind: Test\nmetadata:\nname: my-first-test\nspec:\nfieldA: w\nEOF\n</code></pre> <p>create an object with a fieldA but with 3 char in spec -&gt; accepted</p> <pre><code>kubectl apply -f - &lt;&lt;EOF\napiVersion: foo.example.com/v1alpha1\nkind: Test\nmetadata:\nname: my-first-test\nspec:\nfieldA: wim\nEOF\n</code></pre>"},{"location":"04-devguide/apis/02_kubebuilder/#examples-of-additional-parameters-with-constraints","title":"Examples of additional parameters with constraints","text":"<pre><code>type TestSpec struct {\n// +kubebuilder:validation:MaxItems=2\n// ListA defines a list of A\nListA []string `json:\"listA,omitempty\"`\n// +kubebuilder:validation:Enum=unknown;gnmi;netconf;noop;ssh;\n// +kubebuilder:default:=\"gnmi\"\n// Protocol defines the protocol to connect to the device\nProtocol string `json:\"protocol\"`\n// +kubebuilder:validation:Pattern=`(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])|((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))`\n// Address defines the ip address to connect to the host\nAddress string `json:\"address\"`\n// +kubebuilder:validation:Minimum=1\n// +kubebuilder:validation:Maximum=200\n// +kubebuilder:default:=100\nPriority   *uint8 `json:\"priority,omitempty\"`\n}\n</code></pre>"},{"location":"04-devguide/reconcilers/01_reconciler/","title":"Reconciler Introduction","text":"<p>In <code>Choreo</code>, <code>reconcilers</code> are essential components that synchronize the desired state of resources with their actual state in the system. They are tightly integrated with the API server, responding to changes in resources and executing their corresponding business logic.  </p> <p>When configuring a reconciler in <code>Choreo</code>, developers define two crucial aspects:</p> <ul> <li>Attachment Specifications: Specifies which resources or resource types the reconciler attaches to within the system.</li> <li>Business Logic: Dictates how the reconciler responds to changes, including the transformations it applies to resources.</li> </ul> <p>The attachment is detailed in the reconciler configuration, while the business logic is implemented in the language of the developer\u2019s choice.</p>"},{"location":"04-devguide/reconcilers/01_reconciler/#reconciler-configuration","title":"Reconciler Configuration","text":"<p>Reconcilers in Choreo attach to resources using event handlers, enabling specific interactions based on the resource type:</p> <ul> <li>For Resource: This is the primary resource that the reconciler manages directly. Each instance of this resource is handled in its own Go routine, ensuring isolated and efficient management.</li> <li>Watch Resource: These are the resources that the reconciler depends on for executing its logic. Changes in these resources can trigger the reconciler to act on the primary resource. Examples of watch resources are templates or external source of data</li> <li>Own Resource: These are resources that the reconciler creates as a result of its operations. Managing these resources involves tracking dependencies and cleanup via owner references and finalizers. </li> </ul>"},{"location":"04-devguide/reconcilers/01_reconciler/#reconciler-logic","title":"Reconciler Logic","text":"<p>Reconcilers are designed to be idempotent and language-agnostic, allowing for diverse implementation strategies. In <code>Choreo</code> we aim for ease of use to optimize the development experience.</p> <p>Managing the complete lifecycle of resources\u2014such as creation, updates, and cleanup\u2014can be complex, often requiring developers to handle intricate historical data and state changes. Choreo simplifies this aspect of reconciler implementation by abstracting the historical management of resources, allowing developers to focus solely on specifying the desired state of resources based on current context.</p>"},{"location":"04-devguide/reconcilers/01_reconciler/#reconciler-outcomes","title":"Reconciler Outcomes","text":"<p>The actions a reconciler can take in response to events include:</p> <ul> <li>Done: The reconciler has completed its task with no further actions required.</li> <li>Requeue: The resource needs to be rechecked and possibly reconciled again in the near future.</li> <li>Requeue After: Similar to Requeue, but with a delay specified before the resource is reconsidered.</li> <li>Error: Indicates an issue during reconciliation; this typically leads to an implicit requeue unless handled otherwise.</li> <li>Fatal: A severe error that may require manual intervention or halt further automatic reconciliation under certain conditions.</li> </ul>"},{"location":"04-devguide/reconcilers/01_reconciler/#conflict-resolution","title":"Conflict resolution","text":"<p>To address potential conflicts between multiple reconcilers acting on the same resource, Choreo utilizes server-side apply logic. This approach ensures that each resource parameter is uniquely managed by a specific reconciler, thereby preventing operational overlap and conflicting modifications.</p> <p>Developer Considerations: A developper when designing the system has to ensure a resource parameter is only owned by a given reconciler</p>"},{"location":"04-devguide/reconcilers/02_config/","title":"Reconciler Config","text":"<p>In Choreo, a reconciler configuration is defined within a reconciler resource, where developers specify hooks and their respective parameters. This configuration determines how the reconciler interacts with the system\u2019s resources.</p> <pre><code>apiVersion: choreo.kform.dev/v1alpha1\nkind: Reconciler\n</code></pre>"},{"location":"04-devguide/reconcilers/02_config/#for-resource-hook","title":"For Resource hook","text":"<p>The for resource hook is mandatory and identifies the primary resource that the reconciler manages. It is sometimes referred to as the primary resource.</p> <pre><code>for: group: nf.nephio.org\nversion: v1alpha1\nkind: NFDeployment\nselector:\nmatch:\nspec.provider: upf.free5gc.io\n</code></pre> <p>Parameters:</p> <ul> <li>GVK (Group, Version, Kind): Identifies the for resource.</li> <li>Filters: Specify criteria to select specific resources for reconciliation. These filters use the CEL (Common Expression Language) functionality, allowing for complex logic across all resource fields, including lists and maps. Filters operate under a default-deny policy and require explicit whitelisting.</li> </ul>"},{"location":"04-devguide/reconcilers/02_config/#watch-resource-hook","title":"Watch resource hook","text":"<p>The watch resource hook is optional and used when a reconciler depends on external data or other resources for its logic. Changes in any watched resources specified in the reconciler configuration will trigger the reconciliation process for the associated primary resource.</p> <pre><code>  watches:\n- group: req.nephio.org\nversion: v1alpha1\nkind: Capacity\nselector:\nmatch:\nmetadata.name: upf\n</code></pre> <p>Parameters:</p> <ul> <li>GVK (Group, Version, Kind): Identifies the watch resource.</li> <li>Filters: Optional criteria to identify specific attributes that trigger the reconciliation process. These also operate under a default-deny policy and require whitelisting.</li> </ul>"},{"location":"04-devguide/reconcilers/02_config/#own-resource","title":"Own resource","text":"<p>Reconcilers may define own resources\u2014those they create, update, or delete as a result of their business logic. These resources are often referred to as child resources.</p> <pre><code>  owns:\n- group: req.kuid.dev\nversion: v1alpha1\nkind: Attachment\n</code></pre> <p>Parameters:</p> <pre><code>\u2022   GVK (Group, Version, Kind): Identifies the own resource.\n</code></pre> <p>When the business logic creates child resources it uses owner referernces and finalizers parameters on the child resources: - Owner References are used to track resources created by the reconciler, ensuring that dependency relationships are maintained. - Finalizers are used to allow the reconciler to perform necessary clean-up tasks before the child resource is fully removed from the system.</p> <p>Filtering mechanisms are omitted for owneed resources given there is an explicit parent relationship using onwer references.</p>"},{"location":"04-devguide/reconcilers/02_config/#reocnciler-config-example","title":"Reocnciler config example","text":"<p>Below is a practical example of how to define a reconciler configuration in <code>Choreo</code>. This configuration specifies how the reconciler interacts with various resources, utilizing the for, owns, and watches clauses to manage relationships and dependencies effectively.</p> <pre><code>apiVersion: choreo.kform.dev/v1alpha1\nkind: Reconciler\n# name can be inferred from the filename or from the for resource\nspec: for: group: nf.nephio.org\nversion: v1alpha1\nkind: NFDeployment\nselector:\nmatch:\nspec.provider: upf.free5gc.io\nowns:\n- group: req.kuid.dev\nversion: v1alpha1\nkind: Attachment\n- group: req.kuid.dev\nversion: v1alpha1\nkind: Prefix\nwatches:\n- group: req.nephio.org\nversion: v1alpha1\nkind: Capacity\nselector:\nmatch:\nmetadata.name: upf\n- group: req.nephio.org\nversion: v1alpha1\nkind: Interface\nselector:\nmatch:\nmetadata.name: n3\n- group: req.nephio.org\nversion: v1alpha1\nkind: Interface\nselector:\nmatch:\nmetadata.name: n4\n- group: req.nephio.org\nversion: v1alpha1\nkind: Interface\nselector:\nmatch:\nmetadata.name: n6\n</code></pre>"},{"location":"04-devguide/reconcilers/02_config/#filtering-example-using-cel-expressions","title":"filtering example using cel expressions","text":"<p>This example shows</p> <pre><code>    selector:\nmatch:\nstatus.conditions.exists(c, c.type == 'Ready' &amp;&amp; c.status == 'True'): \"true\"\n</code></pre>"},{"location":"04-devguide/reconcilers/03_gotemplate/","title":"Reconciler Using Go Templates","text":"<p>This chapter explains how to develop a reconciler using Go templates, powerful tools for transforming primary resources into child resources based on the input data. We will cover setting up the reconciler configuration and defining the business logic using Go templates.</p>"},{"location":"04-devguide/reconcilers/03_gotemplate/#reconciler-config","title":"Reconciler config","text":"<p>First, define the reconciler configuration. Go templates act as transformers that attach to a primary resource and generate a new child resource based on the input data. Specify the GVK (Group, Version, Kind) of both the primary and the child resources in your configuration. You can use additional filters to target transformations on resources with specific parameters.</p> <p>In the example below, only interfaces with spec.provider equal to srlinux.nokia.com will be transformed.</p> <pre><code>apiVersion: choreo.kform.dev/v1alpha1\nkind: Reconciler\n# name can be inferred from the filename or from the for resource\nspec: for: group: device.network.kubenet.dev\nversion: v1alpha1\nkind: Interface\nselector: match:\nspec.provider: srlinux.nokia.com\nowns:\n- group: config.sdcio.dev\nversion: v1alpha1\nkind: Config\n</code></pre> <p>Details:</p> <ul> <li>For Resource (for): Specifies the primary resource to which the reconciler attaches.</li> <li>Owns: Defines the type of child resource the reconciler will generate.</li> <li>Selector: Provides filtering capabilities to specify which resources with particular parameters will be transformed.</li> </ul>"},{"location":"04-devguide/reconcilers/03_gotemplate/#go-template-business-logic","title":"Go Template Business Logic","text":"<p>Next, define your reconciler\u2019s business logic as a Go template. The logic can be split across multiple files, but a main file ending with .main.tpl is required. Subsequent files can have any suffix and are referenced within the main template.</p> <p>We recommed using the following structure for the filenames:</p> <p><code>&lt;group&gt;.&lt;kind&gt;.&lt;name&gt;.&lt;suffix&gt;.tpl</code></p>"},{"location":"04-devguide/reconcilers/03_gotemplate/#example","title":"Example","text":"<p>Here\u2019s an example of a Go template that creates a Config resource from an Interface resource:</p> <p>Main template: device.kubenet.dev.interface.config.nokiasrl.main.tpl     - Group: device.kubenet.dev     - Kind: Interface     - Name: config.nokiasrl.main</p> <pre><code>apiVersion: config.sdcio.dev/v1alpha1\nkind: Config\nmetadata:\nname: {{ .metadata.name }}\nnamespace: {{ .metadata.namespace }}\nlabels:\nconfig.sdcio.dev/targetName: {{ .spec.node }}\nconfig.sdcio.dev/targetNamespace: {{ .metadata.namespace }}\nownerReferences:\n- apiVersion: {{ .apiVersion }}\ncontroller: true\nkind: {{ .kind }}\nname: {{ .metadata.name }}\nuid: {{ .metadata.uid }}\nspec:\npriority: 10\nconfig:\n- path: /\nvalue: {{- template \"srlinterface\" .spec}}\n</code></pre> <p>Sub Template: device.kubenet.dev.interface.config.nokiasrl.interface.tpl</p> <p>Here\u2019s an example of a sub-template defined in a separate file, which is referenced in the main template:</p> <pre><code>{{- define \"srlinterface\"}}\ninterface:\n- name: {{ .name }}\ndescription: k8s-{{ .name }}\nadmin-state: enable\n{{- if .vlanTagging}}\nvlan-tagging: true\n{{- end}}\n{{- end }}\n</code></pre> <p>Explanation:</p> <ul> <li>Metadata and Spec Configuration: Uses placeholders to dynamically set values based on the primary resource\u2019s properties.</li> <li>Template Call: {{- template \"srlinterface\" .spec}} calls a defined sub-template that sets additional configuration based on the Interface spec.</li> </ul> <p>Template-based reconcilers support modular and reusable logic, enabling developers familiar with this technology to efficiently leverage existing templates or adapt them for new applications.</p>"},{"location":"04-devguide/reconcilers/04_jinja2template/","title":"Reconciler Using Jinja2 Templates","text":"<p>This chapter explains how to develop a reconciler using Jinja2 templates, for transforming primary resources into child resources based on the input data. We will cover setting up the reconciler configuration and defining the business logic using Jinja2 templates.</p>"},{"location":"04-devguide/reconcilers/04_jinja2template/#reconciler-config","title":"Reconciler config","text":"<p>First, define the reconciler configuration. Jinja2 templates act as transformers that attach to a primary resource and generate a new child resource based on the input data. Specify the GVK (Group, Version, Kind) of both the primary and the child resources in your configuration. You can use additional filters to target transformations on resources with specific parameters.</p> <p>In the example below, only interfaces with spec.provider equal to srlinux.nokia.com will be transformed.</p> <pre><code>apiVersion: choreo.kform.dev/v1alpha1\nkind: Reconciler\n# name can be inferred from the filename or from the for resource\nspec: for: group: device.network.kubenet.dev\nversion: v1alpha1\nkind: Interface\nselector: match:\nspec.provider: srlinux.nokia.com\nowns:\n- group: config.sdcio.dev\nversion: v1alpha1\nkind: Config\n</code></pre> <p>Details:</p> <ul> <li>For Resource (for): Specifies the primary resource to which the reconciler attaches.</li> <li>Owns: Defines the type of child resource the reconciler will generate.</li> <li>Selector: Provides filtering capabilities to specify which resources with particular parameters will be transformed.</li> </ul>"},{"location":"04-devguide/reconcilers/04_jinja2template/#jinja2-template-business-logic","title":"Jinja2 Template Business Logic","text":"<p>Next, define your reconciler\u2019s business logic as a Jinja2 template. The logic can be split across multiple files, but a main file ending with .main.jinja2 is required. Subsequent files can have any suffix and are referenced within the main template.</p> <p>We recommed using the following structure for the filenames:</p> <p><code>&lt;group&gt;.&lt;kind&gt;.&lt;name&gt;.&lt;suffix&gt;.jinja2</code></p>"},{"location":"04-devguide/reconcilers/04_jinja2template/#example","title":"Example","text":"<p>Here\u2019s an example of a Go template that creates a Config resource from an Interface resource:</p> <p>Main template: device.kubenet.dev.interface.config.nokiasrl.main.jinja2     - Group: device.kubenet.dev     - Kind: Interface     - Name: config.nokiasrl.main</p> <pre><code>{%- import 'interface.jinja2' interface -%}\napiVersion: config.sdcio.dev/v1alpha1\nkind: Config\nmetadata:\nname: {{ metadata.name }}\nnamespace: {{ metadata.namespace }}\nlabels:\nconfig.sdcio.dev/targetName: {{ spec.node }}\nconfig.sdcio.dev/targetNamespace: {{ metadata.namespace }}\nownerReferences:\n- apiVersion: {{ apiVersion }}\ncontroller: true\nkind: {{ kind }}\nname: {{ metadata.name }}\nuid: {{ metadata.uid }}\nspec:\npriority: 10\nconfig:\n- path: /\nvalue: {{ interface(spec) -}} </code></pre> <p>Sub Template: device.kubenet.dev.interface.config.nokiasrl.interface.jinja2</p> <p>Here\u2019s an example of a sub-template defined in a separate file, which is referenced in the main template:</p> <pre><code>{%- macro interface(spec) export -%}\ninterface:\n- name: {{ spec.name }}\ndescription: k8s-{{ spec.name }}\nadmin-state: enable\n{%- if spec.vlanTagging %}\nvlan-tagging: true\n{%- endif %}\n{%- endmacro %}\n</code></pre> <p>Explanation:</p> <ul> <li>Metadata and Spec Configuration: Uses placeholders to dynamically set values based on the primary resource\u2019s properties.</li> <li>Template Call: {%- import 'interface.jinja2' interface -%} calls a defined sub-template that sets additional configuration based on the Interface spec.</li> </ul> <p>Template-based reconcilers support modular and reusable logic, enabling developers familiar with this technology to efficiently leverage existing templates or adapt them for new applications.</p>"},{"location":"05-examples/01_about/","title":"About","text":"<p>In the following repo you can find some choreo example to help you understand the concepts and scenario's </p> <p>choreo examples</p>"},{"location":"06-rn/0.0.14/","title":"Release notes","text":"<p>v0.0.14 release notes</p>"},{"location":"06-rn/0.0.15/","title":"Release notes","text":"<p>v0.0.15 release notes</p>"},{"location":"06-rn/0.0.16/","title":"Release notes","text":"<p>v0.0.16 release notes</p>"},{"location":"06-rn/0.0.17/","title":"Release notes","text":"<p>v0.0.17 release notes</p>"},{"location":"06-rn/rn/","title":"Kform release notes","text":"<p>We are stil in the early phases of our development, therefore we do not publish aggregated release notes for each of our releases. </p> <p>Release summaries are available on GitHub:</p> <ul> <li>Choreo</li> </ul>"},{"location":"07-community/01_about/","title":"Community","text":"<p>Join us in this jurney to build the power of 'KRM as code or data' to Kubernetes. We are happy to help and would like to learn your user stories in discord server.</p> <p>Choreo was started and currently maintained by Nokia with the clear target to make the project community driven.</p>"},{"location":"07-community/01_about/#kubenet","title":"Kubenet","text":"<p>If you are intrested in a biger picture about how do we imagine network automation in a Kubernetes native way check out Kubenet. </p>"},{"location":"07-community/01_about/#logos","title":"Logos","text":"<p>Logos of Kform in different formats:</p> <ul> <li>With name 100x123 png</li> <li>With name 503x690 png</li> <li>Without name 100x100 png</li> <li>With name svg</li> <li>Without name svg</li> </ul> <p></p>"}]}